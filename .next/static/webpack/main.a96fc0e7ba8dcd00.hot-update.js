"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("main",{

/***/ "(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/router.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/router.js ***!
  \************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("// tslint:disable:no-console\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  createKey: function () {\n    return createKey;\n  },\n  default: function () {\n    return Router;\n  },\n  matchesMiddleware: function () {\n    return matchesMiddleware;\n  }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(pages-dir-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(pages-dir-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _removetrailingslash = __webpack_require__(/*! ./utils/remove-trailing-slash */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\nconst _routeloader = __webpack_require__(/*! ../../../client/route-loader */ \"(pages-dir-browser)/./node_modules/next/dist/client/route-loader.js\");\nconst _script = __webpack_require__(/*! ../../../client/script */ \"(pages-dir-browser)/./node_modules/next/dist/client/script.js\");\nconst _iserror = /*#__PURE__*/_interop_require_wildcard._(__webpack_require__(/*! ../../../lib/is-error */ \"(pages-dir-browser)/./node_modules/next/dist/lib/is-error.js\"));\nconst _denormalizepagepath = __webpack_require__(/*! ../page-path/denormalize-page-path */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/page-path/denormalize-page-path.js\");\nconst _normalizelocalepath = __webpack_require__(/*! ../i18n/normalize-locale-path */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js\");\nconst _mitt = /*#__PURE__*/_interop_require_default._(__webpack_require__(/*! ../mitt */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/mitt.js\"));\nconst _utils = __webpack_require__(/*! ../utils */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nconst _isdynamic = __webpack_require__(/*! ./utils/is-dynamic */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\nconst _parserelativeurl = __webpack_require__(/*! ./utils/parse-relative-url */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js\");\nconst _resolverewrites = /*#__PURE__*/_interop_require_default._(__webpack_require__(/*! ./utils/resolve-rewrites */ \"?506d\"));\nconst _routematcher = __webpack_require__(/*! ./utils/route-matcher */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/route-matcher.js\");\nconst _routeregex = __webpack_require__(/*! ./utils/route-regex */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/route-regex.js\");\nconst _formaturl = __webpack_require__(/*! ./utils/format-url */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nconst _detectdomainlocale = __webpack_require__(/*! ../../../client/detect-domain-locale */ \"(pages-dir-browser)/./node_modules/next/dist/client/detect-domain-locale.js\");\nconst _parsepath = __webpack_require__(/*! ./utils/parse-path */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/parse-path.js\");\nconst _addlocale = __webpack_require__(/*! ../../../client/add-locale */ \"(pages-dir-browser)/./node_modules/next/dist/client/add-locale.js\");\nconst _removelocale = __webpack_require__(/*! ../../../client/remove-locale */ \"(pages-dir-browser)/./node_modules/next/dist/client/remove-locale.js\");\nconst _removebasepath = __webpack_require__(/*! ../../../client/remove-base-path */ \"(pages-dir-browser)/./node_modules/next/dist/client/remove-base-path.js\");\nconst _addbasepath = __webpack_require__(/*! ../../../client/add-base-path */ \"(pages-dir-browser)/./node_modules/next/dist/client/add-base-path.js\");\nconst _hasbasepath = __webpack_require__(/*! ../../../client/has-base-path */ \"(pages-dir-browser)/./node_modules/next/dist/client/has-base-path.js\");\nconst _resolvehref = __webpack_require__(/*! ../../../client/resolve-href */ \"(pages-dir-browser)/./node_modules/next/dist/client/resolve-href.js\");\nconst _isapiroute = __webpack_require__(/*! ../../../lib/is-api-route */ \"(pages-dir-browser)/./node_modules/next/dist/lib/is-api-route.js\");\nconst _getnextpathnameinfo = __webpack_require__(/*! ./utils/get-next-pathname-info */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js\");\nconst _formatnextpathnameinfo = __webpack_require__(/*! ./utils/format-next-pathname-info */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js\");\nconst _comparestates = __webpack_require__(/*! ./utils/compare-states */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/compare-states.js\");\nconst _islocalurl = __webpack_require__(/*! ./utils/is-local-url */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nconst _isbot = __webpack_require__(/*! ./utils/is-bot */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/is-bot.js\");\nconst _omit = __webpack_require__(/*! ./utils/omit */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/omit.js\");\nconst _interpolateas = __webpack_require__(/*! ./utils/interpolate-as */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\");\nconst _handlesmoothscroll = __webpack_require__(/*! ./utils/handle-smooth-scroll */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js\");\nconst _constants = __webpack_require__(/*! ../../../lib/constants */ \"(pages-dir-browser)/./node_modules/next/dist/lib/constants.js\");\nfunction buildCancellationError() {\n  return Object.assign(Object.defineProperty(new Error('Route Cancelled'), \"__NEXT_ERROR_CODE\", {\n    value: \"E315\",\n    enumerable: false,\n    configurable: true\n  }), {\n    cancelled: true\n  });\n}\nasync function matchesMiddleware(options) {\n  const matchers = await Promise.resolve(options.router.pageLoader.getMiddleware());\n  if (!matchers) return false;\n  const {\n    pathname: asPathname\n  } = (0, _parsepath.parsePath)(options.asPath);\n  // remove basePath first since path prefix has to be in the order of `/${basePath}/${locale}`\n  const cleanedAs = (0, _hasbasepath.hasBasePath)(asPathname) ? (0, _removebasepath.removeBasePath)(asPathname) : asPathname;\n  const asWithBasePathAndLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(cleanedAs, options.locale));\n  // Check only path match on client. Matching \"has\" should be done on server\n  // where we can access more info such as headers, HttpOnly cookie, etc.\n  return matchers.some(m => new RegExp(m.regexp).test(asWithBasePathAndLocale));\n}\nfunction stripOrigin(url) {\n  const origin = (0, _utils.getLocationOrigin)();\n  return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\nfunction prepareUrlAs(router, url, as) {\n  // If url and as provided as an object representation,\n  // we'll format them into the string version here.\n  let [resolvedHref, resolvedAs] = (0, _resolvehref.resolveHref)(router, url, true);\n  const origin = (0, _utils.getLocationOrigin)();\n  const hrefWasAbsolute = resolvedHref.startsWith(origin);\n  const asWasAbsolute = resolvedAs && resolvedAs.startsWith(origin);\n  resolvedHref = stripOrigin(resolvedHref);\n  resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n  const preparedUrl = hrefWasAbsolute ? resolvedHref : (0, _addbasepath.addBasePath)(resolvedHref);\n  const preparedAs = as ? stripOrigin((0, _resolvehref.resolveHref)(router, as)) : resolvedAs || resolvedHref;\n  return {\n    url: preparedUrl,\n    as: asWasAbsolute ? preparedAs : (0, _addbasepath.addBasePath)(preparedAs)\n  };\n}\nfunction resolveDynamicRoute(pathname, pages) {\n  const cleanPathname = (0, _removetrailingslash.removeTrailingSlash)((0, _denormalizepagepath.denormalizePagePath)(pathname));\n  if (cleanPathname === '/404' || cleanPathname === '/_error') {\n    return pathname;\n  }\n  // handle resolving href for dynamic routes\n  if (!pages.includes(cleanPathname)) {\n    // eslint-disable-next-line array-callback-return\n    pages.some(page => {\n      if ((0, _isdynamic.isDynamicRoute)(page) && (0, _routeregex.getRouteRegex)(page).re.test(cleanPathname)) {\n        pathname = page;\n        return true;\n      }\n    });\n  }\n  return (0, _removetrailingslash.removeTrailingSlash)(pathname);\n}\nfunction getMiddlewareData(source, response, options) {\n  const nextConfig = {\n    basePath: options.router.basePath,\n    i18n: {\n      locales: options.router.locales\n    },\n    trailingSlash: Boolean(false)\n  };\n  const rewriteHeader = response.headers.get('x-nextjs-rewrite');\n  let rewriteTarget = rewriteHeader || response.headers.get('x-nextjs-matched-path');\n  const matchedPath = response.headers.get(_constants.MATCHED_PATH_HEADER);\n  if (matchedPath && !rewriteTarget && !matchedPath.includes('__next_data_catchall') && !matchedPath.includes('/_error') && !matchedPath.includes('/404')) {\n    // leverage x-matched-path to detect next.config.js rewrites\n    rewriteTarget = matchedPath;\n  }\n  if (rewriteTarget) {\n    if (rewriteTarget.startsWith('/') || false) {\n      const parsedRewriteTarget = (0, _parserelativeurl.parseRelativeUrl)(rewriteTarget);\n      const pathnameInfo = (0, _getnextpathnameinfo.getNextPathnameInfo)(parsedRewriteTarget.pathname, {\n        nextConfig,\n        parseData: true\n      });\n      let fsPathname = (0, _removetrailingslash.removeTrailingSlash)(pathnameInfo.pathname);\n      return Promise.all([options.router.pageLoader.getPageList(), (0, _routeloader.getClientBuildManifest)()]).then(param => {\n        let [pages, {\n          __rewrites: rewrites\n        }] = param;\n        let as = (0, _addlocale.addLocale)(pathnameInfo.pathname, pathnameInfo.locale);\n        if ((0, _isdynamic.isDynamicRoute)(as) || !rewriteHeader && pages.includes((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(as), options.router.locales).pathname)) {\n          const parsedSource = (0, _getnextpathnameinfo.getNextPathnameInfo)((0, _parserelativeurl.parseRelativeUrl)(source).pathname, {\n            nextConfig:  false ? 0 : nextConfig,\n            parseData: true\n          });\n          as = (0, _addbasepath.addBasePath)(parsedSource.pathname);\n          parsedRewriteTarget.pathname = as;\n        }\n        if (false) {} else if (!pages.includes(fsPathname)) {\n          const resolvedPathname = resolveDynamicRoute(fsPathname, pages);\n          if (resolvedPathname !== fsPathname) {\n            fsPathname = resolvedPathname;\n          }\n        }\n        const resolvedHref = !pages.includes(fsPathname) ? resolveDynamicRoute((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(parsedRewriteTarget.pathname), options.router.locales).pathname, pages) : fsPathname;\n        if ((0, _isdynamic.isDynamicRoute)(resolvedHref)) {\n          const matches = (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(resolvedHref))(as);\n          Object.assign(parsedRewriteTarget.query, matches || {});\n        }\n        return {\n          type: 'rewrite',\n          parsedAs: parsedRewriteTarget,\n          resolvedHref\n        };\n      });\n    }\n    const src = (0, _parsepath.parsePath)(source);\n    const pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)({\n      ...(0, _getnextpathnameinfo.getNextPathnameInfo)(src.pathname, {\n        nextConfig,\n        parseData: true\n      }),\n      defaultLocale: options.router.defaultLocale,\n      buildId: ''\n    });\n    return Promise.resolve({\n      type: 'redirect-external',\n      destination: \"\" + pathname + src.query + src.hash\n    });\n  }\n  const redirectTarget = response.headers.get('x-nextjs-redirect');\n  if (redirectTarget) {\n    if (redirectTarget.startsWith('/')) {\n      const src = (0, _parsepath.parsePath)(redirectTarget);\n      const pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)({\n        ...(0, _getnextpathnameinfo.getNextPathnameInfo)(src.pathname, {\n          nextConfig,\n          parseData: true\n        }),\n        defaultLocale: options.router.defaultLocale,\n        buildId: ''\n      });\n      return Promise.resolve({\n        type: 'redirect-internal',\n        newAs: \"\" + pathname + src.query + src.hash,\n        newUrl: \"\" + pathname + src.query + src.hash\n      });\n    }\n    return Promise.resolve({\n      type: 'redirect-external',\n      destination: redirectTarget\n    });\n  }\n  return Promise.resolve({\n    type: 'next'\n  });\n}\nasync function withMiddlewareEffects(options) {\n  const matches = await matchesMiddleware(options);\n  if (!matches || !options.fetchData) {\n    return null;\n  }\n  const data = await options.fetchData();\n  const effect = await getMiddlewareData(data.dataHref, data.response, options);\n  return {\n    dataHref: data.dataHref,\n    json: data.json,\n    response: data.response,\n    text: data.text,\n    cacheKey: data.cacheKey,\n    effect\n  };\n}\nconst manualScrollRestoration =  false && 0;\nconst SSG_DATA_NOT_FOUND = Symbol('SSG_DATA_NOT_FOUND');\nfunction fetchRetry(url, attempts, options) {\n  return fetch(url, {\n    // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n    // Cookies may also be required for `getServerSideProps`.\n    //\n    // > `fetch` won’t send cookies, unless you set the credentials init\n    // > option.\n    // https://developer.mozilla.org/docs/Web/API/Fetch_API/Using_Fetch\n    //\n    // > For maximum browser compatibility when it comes to sending &\n    // > receiving cookies, always supply the `credentials: 'same-origin'`\n    // > option instead of relying on the default.\n    // https://github.com/github/fetch#caveats\n    credentials: 'same-origin',\n    method: options.method || 'GET',\n    headers: Object.assign({}, options.headers, {\n      'x-nextjs-data': '1'\n    })\n  }).then(response => {\n    return !response.ok && attempts > 1 && response.status >= 500 ? fetchRetry(url, attempts - 1, options) : response;\n  });\n}\nfunction tryToParseAsJSON(text) {\n  try {\n    return JSON.parse(text);\n  } catch (error) {\n    return null;\n  }\n}\nfunction fetchNextData(param) {\n  let {\n    dataHref,\n    inflightCache,\n    isPrefetch,\n    hasMiddleware,\n    isServerRender,\n    parseJSON,\n    persistCache,\n    isBackground,\n    unstable_skipClientCache\n  } = param;\n  const {\n    href: cacheKey\n  } = new URL(dataHref, window.location.href);\n  const getData = params => {\n    var _params_method;\n    return fetchRetry(dataHref, isServerRender ? 3 : 1, {\n      headers: Object.assign({}, isPrefetch ? {\n        purpose: 'prefetch'\n      } : {}, isPrefetch && hasMiddleware ? {\n        'x-middleware-prefetch': '1'\n      } : {},  false ? 0 : {}),\n      method: (_params_method = params == null ? void 0 : params.method) != null ? _params_method : 'GET'\n    }).then(response => {\n      if (response.ok && (params == null ? void 0 : params.method) === 'HEAD') {\n        return {\n          dataHref,\n          response,\n          text: '',\n          json: {},\n          cacheKey\n        };\n      }\n      return response.text().then(text => {\n        if (!response.ok) {\n          /**\n          * When the data response is a redirect because of a middleware\n          * we do not consider it an error. The headers must bring the\n          * mapped location.\n          * TODO: Change the status code in the handler.\n          */\n          if (hasMiddleware && [301, 302, 307, 308].includes(response.status)) {\n            return {\n              dataHref,\n              response,\n              text,\n              json: {},\n              cacheKey\n            };\n          }\n          if (response.status === 404) {\n            var _tryToParseAsJSON;\n            if ((_tryToParseAsJSON = tryToParseAsJSON(text)) == null ? void 0 : _tryToParseAsJSON.notFound) {\n              return {\n                dataHref,\n                json: {\n                  notFound: SSG_DATA_NOT_FOUND\n                },\n                response,\n                text,\n                cacheKey\n              };\n            }\n          }\n          const error = Object.defineProperty(new Error(\"Failed to load static props\"), \"__NEXT_ERROR_CODE\", {\n            value: \"E124\",\n            enumerable: false,\n            configurable: true\n          });\n          /**\n          * We should only trigger a server-side transition if this was\n          * caused on a client-side transition. Otherwise, we'd get into\n          * an infinite loop.\n          */\n          if (!isServerRender) {\n            (0, _routeloader.markAssetError)(error);\n          }\n          throw error;\n        }\n        return {\n          dataHref,\n          json: parseJSON ? tryToParseAsJSON(text) : null,\n          response,\n          text,\n          cacheKey\n        };\n      });\n    }).then(data => {\n      if (!persistCache || true || 0) {\n        delete inflightCache[cacheKey];\n      }\n      return data;\n    }).catch(err => {\n      if (!unstable_skipClientCache) {\n        delete inflightCache[cacheKey];\n      }\n      if (\n      // chrome\n      err.message === 'Failed to fetch' ||\n      // firefox\n      err.message === 'NetworkError when attempting to fetch resource.' ||\n      // safari\n      err.message === 'Load failed') {\n        (0, _routeloader.markAssetError)(err);\n      }\n      throw err;\n    });\n  };\n  // when skipping client cache we wait to update\n  // inflight cache until successful data response\n  // this allows racing click event with fetching newer data\n  // without blocking navigation when stale data is available\n  if (unstable_skipClientCache && persistCache) {\n    return getData({}).then(data => {\n      if (data.response.headers.get('x-middleware-cache') !== 'no-cache') {\n        // only update cache if not marked as no-cache\n        inflightCache[cacheKey] = Promise.resolve(data);\n      }\n      return data;\n    });\n  }\n  if (inflightCache[cacheKey] !== undefined) {\n    return inflightCache[cacheKey];\n  }\n  return inflightCache[cacheKey] = getData(isBackground ? {\n    method: 'HEAD'\n  } : {});\n}\nfunction createKey() {\n  return Math.random().toString(36).slice(2, 10);\n}\nfunction handleHardNavigation(param) {\n  let {\n    url,\n    router\n  } = param;\n  // ensure we don't trigger a hard navigation to the same\n  // URL as this can end up with an infinite refresh\n  if (url === (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(router.asPath, router.locale))) {\n    throw Object.defineProperty(new Error(\"Invariant: attempted to hard navigate to the same URL \" + url + \" \" + location.href), \"__NEXT_ERROR_CODE\", {\n      value: \"E282\",\n      enumerable: false,\n      configurable: true\n    });\n  }\n  window.location.href = url;\n}\nconst getCancelledHandler = param => {\n  let {\n    route,\n    router\n  } = param;\n  let cancelled = false;\n  const cancel = router.clc = () => {\n    cancelled = true;\n  };\n  const handleCancelled = () => {\n    if (cancelled) {\n      const error = Object.defineProperty(new Error('Abort fetching component for route: \"' + route + '\"'), \"__NEXT_ERROR_CODE\", {\n        value: \"E483\",\n        enumerable: false,\n        configurable: true\n      });\n      error.cancelled = true;\n      throw error;\n    }\n    if (cancel === router.clc) {\n      router.clc = null;\n    }\n  };\n  return handleCancelled;\n};\nclass Router {\n  reload() {\n    window.location.reload();\n  }\n  /**\n  * Go back in history\n  */\n  back() {\n    window.history.back();\n  }\n  /**\n  * Go forward in history\n  */\n  forward() {\n    window.history.forward();\n  }\n  /**\n  * Performs a `pushState` with arguments\n  * @param url of the route\n  * @param as masks `url` for the browser\n  * @param options object you can define `shallow` and other options\n  */\n  push(url, as, options) {\n    if (options === void 0) options = {};\n    if (false) {}\n    ;\n    ({\n      url,\n      as\n    } = prepareUrlAs(this, url, as));\n    return this.change('pushState', url, as, options);\n  }\n  /**\n  * Performs a `replaceState` with arguments\n  * @param url of the route\n  * @param as masks `url` for the browser\n  * @param options object you can define `shallow` and other options\n  */\n  replace(url, as, options) {\n    if (options === void 0) options = {};\n    ;\n    ({\n      url,\n      as\n    } = prepareUrlAs(this, url, as));\n    return this.change('replaceState', url, as, options);\n  }\n  async _bfl(as, resolvedAs, locale, skipNavigate) {\n    if (true) {\n      if (!this._bfl_s && !this._bfl_d) {\n        const {\n          BloomFilter\n        } = __webpack_require__(/*! ../../lib/bloom-filter */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/bloom-filter.js\");\n        let staticFilterData;\n        let dynamicFilterData;\n        try {\n          ;\n          ({\n            __routerFilterStatic: staticFilterData,\n            __routerFilterDynamic: dynamicFilterData\n          } = await (0, _routeloader.getClientBuildManifest)());\n        } catch (err) {\n          // failed to load build manifest hard navigate\n          // to be safe\n          console.error(err);\n          if (skipNavigate) {\n            return true;\n          }\n          handleHardNavigation({\n            url: (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, locale || this.locale, this.defaultLocale)),\n            router: this\n          });\n          return new Promise(() => {});\n        }\n        const routerFilterSValue = {\"numItems\":4,\"errorRate\":0.0001,\"numBits\":77,\"numHashes\":14,\"bitArray\":[0,0,1,0,1,0,1,1,0,0,1,0,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,0,0,1,0,0,0,1,1,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,1,1,0,1,0,0,1,1,0,0,0,0,1]};\n        if (!staticFilterData && routerFilterSValue) {\n          staticFilterData = routerFilterSValue ? routerFilterSValue : undefined;\n        }\n        const routerFilterDValue = {\"numItems\":1,\"errorRate\":0.0001,\"numBits\":20,\"numHashes\":14,\"bitArray\":[1,1,1,1,0,1,0,0,1,1,0,1,0,0,0,1,1,1,0,1]};\n        if (!dynamicFilterData && routerFilterDValue) {\n          dynamicFilterData = routerFilterDValue ? routerFilterDValue : undefined;\n        }\n        if (staticFilterData == null ? void 0 : staticFilterData.numHashes) {\n          this._bfl_s = new BloomFilter(staticFilterData.numItems, staticFilterData.errorRate);\n          this._bfl_s.import(staticFilterData);\n        }\n        if (dynamicFilterData == null ? void 0 : dynamicFilterData.numHashes) {\n          this._bfl_d = new BloomFilter(dynamicFilterData.numItems, dynamicFilterData.errorRate);\n          this._bfl_d.import(dynamicFilterData);\n        }\n      }\n      let matchesBflStatic = false;\n      let matchesBflDynamic = false;\n      const pathsToCheck = [{\n        as\n      }, {\n        as: resolvedAs\n      }];\n      for (const {\n        as: curAs,\n        allowMatchCurrent\n      } of pathsToCheck) {\n        if (curAs) {\n          const asNoSlash = (0, _removetrailingslash.removeTrailingSlash)(new URL(curAs, 'http://n').pathname);\n          const asNoSlashLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asNoSlash, locale || this.locale));\n          if (allowMatchCurrent || asNoSlash !== (0, _removetrailingslash.removeTrailingSlash)(new URL(this.asPath, 'http://n').pathname)) {\n            var _this__bfl_s, _this__bfl_s1;\n            matchesBflStatic = matchesBflStatic || !!((_this__bfl_s = this._bfl_s) == null ? void 0 : _this__bfl_s.contains(asNoSlash)) || !!((_this__bfl_s1 = this._bfl_s) == null ? void 0 : _this__bfl_s1.contains(asNoSlashLocale));\n            for (const normalizedAS of [asNoSlash, asNoSlashLocale]) {\n              // if any sub-path of as matches a dynamic filter path\n              // it should be hard navigated\n              const curAsParts = normalizedAS.split('/');\n              for (let i = 0; !matchesBflDynamic && i < curAsParts.length + 1; i++) {\n                var _this__bfl_d;\n                const currentPart = curAsParts.slice(0, i).join('/');\n                if (currentPart && ((_this__bfl_d = this._bfl_d) == null ? void 0 : _this__bfl_d.contains(currentPart))) {\n                  matchesBflDynamic = true;\n                  break;\n                }\n              }\n            }\n            // if the client router filter is matched then we trigger\n            // a hard navigation\n            if (matchesBflStatic || matchesBflDynamic) {\n              if (skipNavigate) {\n                return true;\n              }\n              handleHardNavigation({\n                url: (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, locale || this.locale, this.defaultLocale)),\n                router: this\n              });\n              return new Promise(() => {});\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }\n  async change(method, url, as, options, forcedScroll) {\n    var _this_components_pathname;\n    if (!(0, _islocalurl.isLocalURL)(url)) {\n      handleHardNavigation({\n        url,\n        router: this\n      });\n      return false;\n    }\n    // WARNING: `_h` is an internal option for handing Next.js client-side\n    // hydration. Your app should _never_ use this property. It may change at\n    // any time without notice.\n    const isQueryUpdating = options._h === 1;\n    if (!isQueryUpdating && !options.shallow) {\n      await this._bfl(as, undefined, options.locale);\n    }\n    let shouldResolveHref = isQueryUpdating || options._shouldResolveHref || (0, _parsepath.parsePath)(url).pathname === (0, _parsepath.parsePath)(as).pathname;\n    const nextState = {\n      ...this.state\n    };\n    // for static pages with query params in the URL we delay\n    // marking the router ready until after the query is updated\n    // or a navigation has occurred\n    const readyStateChange = this.isReady !== true;\n    this.isReady = true;\n    const isSsr = this.isSsr;\n    if (!isQueryUpdating) {\n      this.isSsr = false;\n    }\n    // if a route transition is already in progress before\n    // the query updating is triggered ignore query updating\n    if (isQueryUpdating && this.clc) {\n      return false;\n    }\n    const prevLocale = nextState.locale;\n    if (false) { var _this_locales; }\n    // marking route changes as a navigation start entry\n    if (_utils.ST) {\n      performance.mark('routeChange');\n    }\n    const {\n      shallow = false,\n      scroll = true\n    } = options;\n    const routeProps = {\n      shallow\n    };\n    if (this._inFlightRoute && this.clc) {\n      if (!isSsr) {\n        Router.events.emit('routeChangeError', buildCancellationError(), this._inFlightRoute, routeProps);\n      }\n      this.clc();\n      this.clc = null;\n    }\n    as = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, options.locale, this.defaultLocale));\n    const cleanedAs = (0, _removelocale.removeLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, nextState.locale);\n    this._inFlightRoute = as;\n    const localeChange = prevLocale !== nextState.locale;\n    // If the url change is only related to a hash change\n    // We should not proceed. We should only change the state.\n    if (!isQueryUpdating && this.onlyAHashChange(cleanedAs) && !localeChange) {\n      nextState.asPath = cleanedAs;\n      Router.events.emit('hashChangeStart', as, routeProps);\n      // TODO: do we need the resolved href when only a hash change?\n      this.changeState(method, url, as, {\n        ...options,\n        scroll: false\n      });\n      if (scroll) {\n        this.scrollToHash(cleanedAs);\n      }\n      try {\n        await this.set(nextState, this.components[nextState.route], null);\n      } catch (err) {\n        if ((0, _iserror.default)(err) && err.cancelled) {\n          Router.events.emit('routeChangeError', err, cleanedAs, routeProps);\n        }\n        throw err;\n      }\n      Router.events.emit('hashChangeComplete', as, routeProps);\n      return true;\n    }\n    let parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n    let {\n      pathname,\n      query\n    } = parsed;\n    // The build manifest needs to be loaded before auto-static dynamic pages\n    // get their query parameters to allow ensuring they can be parsed properly\n    // when rewritten to\n    let pages, rewrites;\n    try {\n      ;\n      [pages, {\n        __rewrites: rewrites\n      }] = await Promise.all([this.pageLoader.getPageList(), (0, _routeloader.getClientBuildManifest)(), this.pageLoader.getMiddleware()]);\n    } catch (err) {\n      // If we fail to resolve the page list or client-build manifest, we must\n      // do a server-side transition:\n      handleHardNavigation({\n        url: as,\n        router: this\n      });\n      return false;\n    }\n    // If asked to change the current URL we should reload the current page\n    // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n    // We also need to set the method = replaceState always\n    // as this should not go into the history (That's how browsers work)\n    // We should compare the new asPath to the current asPath, not the url\n    if (!this.urlIsNew(cleanedAs) && !localeChange) {\n      method = 'replaceState';\n    }\n    // we need to resolve the as value using rewrites for dynamic SSG\n    // pages to allow building the data URL correctly\n    let resolvedAs = as;\n    // url and as should always be prefixed with basePath by this\n    // point by either next/link or router.push/replace so strip the\n    // basePath from the pathname to match the pages dir 1-to-1\n    pathname = pathname ? (0, _removetrailingslash.removeTrailingSlash)((0, _removebasepath.removeBasePath)(pathname)) : pathname;\n    let route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n    const parsedAsPathname = as.startsWith('/') && (0, _parserelativeurl.parseRelativeUrl)(as).pathname;\n    // if we detected the path as app route during prefetching\n    // trigger hard navigation\n    if ((_this_components_pathname = this.components[pathname]) == null ? void 0 : _this_components_pathname.__appRouter) {\n      handleHardNavigation({\n        url: as,\n        router: this\n      });\n      return new Promise(() => {});\n    }\n    const isMiddlewareRewrite = !!(parsedAsPathname && route !== parsedAsPathname && (!(0, _isdynamic.isDynamicRoute)(route) || !(0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(route))(parsedAsPathname)));\n    // we don't attempt resolve asPath when we need to execute\n    // middleware as the resolving will occur server-side\n    const isMiddlewareMatch = !options.shallow && (await matchesMiddleware({\n      asPath: as,\n      locale: nextState.locale,\n      router: this\n    }));\n    if (isQueryUpdating && isMiddlewareMatch) {\n      shouldResolveHref = false;\n    }\n    if (shouldResolveHref && pathname !== '/_error') {\n      ;\n      options._shouldResolveHref = true;\n      if (false) {} else {\n        parsed.pathname = resolveDynamicRoute(pathname, pages);\n        if (parsed.pathname !== pathname) {\n          pathname = parsed.pathname;\n          parsed.pathname = (0, _addbasepath.addBasePath)(pathname);\n          if (!isMiddlewareMatch) {\n            url = (0, _formaturl.formatWithValidation)(parsed);\n          }\n        }\n      }\n    }\n    if (!(0, _islocalurl.isLocalURL)(as)) {\n      if (true) {\n        throw Object.defineProperty(new Error('Invalid href: \"' + url + '\" and as: \"' + as + '\", received relative href and external as' + \"\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as\"), \"__NEXT_ERROR_CODE\", {\n          value: \"E380\",\n          enumerable: false,\n          configurable: true\n        });\n      }\n      handleHardNavigation({\n        url: as,\n        router: this\n      });\n      return false;\n    }\n    resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(resolvedAs), nextState.locale);\n    route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n    let routeMatch = false;\n    if ((0, _isdynamic.isDynamicRoute)(route)) {\n      const parsedAs = (0, _parserelativeurl.parseRelativeUrl)(resolvedAs);\n      const asPathname = parsedAs.pathname;\n      const routeRegex = (0, _routeregex.getRouteRegex)(route);\n      routeMatch = (0, _routematcher.getRouteMatcher)(routeRegex)(asPathname);\n      const shouldInterpolate = route === asPathname;\n      const interpolatedAs = shouldInterpolate ? (0, _interpolateas.interpolateAs)(route, asPathname, query) : {};\n      if (!routeMatch || shouldInterpolate && !interpolatedAs.result) {\n        const missingParams = Object.keys(routeRegex.groups).filter(param => !query[param] && !routeRegex.groups[param].optional);\n        if (missingParams.length > 0 && !isMiddlewareMatch) {\n          if (true) {\n            console.warn(\"\" + (shouldInterpolate ? \"Interpolating href\" : \"Mismatching `as` and `href`\") + \" failed to manually provide \" + (\"the params: \" + missingParams.join(', ') + \" in the `href`'s `query`\"));\n          }\n          throw Object.defineProperty(new Error((shouldInterpolate ? \"The provided `href` (\" + url + \") value is missing query values (\" + missingParams.join(', ') + \") to be interpolated properly. \" : \"The provided `as` value (\" + asPathname + \") is incompatible with the `href` value (\" + route + \"). \") + (\"Read more: https://nextjs.org/docs/messages/\" + (shouldInterpolate ? 'href-interpolation-failed' : 'incompatible-href-as'))), \"__NEXT_ERROR_CODE\", {\n            value: \"E344\",\n            enumerable: false,\n            configurable: true\n          });\n        }\n      } else if (shouldInterpolate) {\n        as = (0, _formaturl.formatWithValidation)(Object.assign({}, parsedAs, {\n          pathname: interpolatedAs.result,\n          query: (0, _omit.omit)(query, interpolatedAs.params)\n        }));\n      } else {\n        // Merge params into `query`, overwriting any specified in search\n        Object.assign(query, routeMatch);\n      }\n    }\n    if (!isQueryUpdating) {\n      Router.events.emit('routeChangeStart', as, routeProps);\n    }\n    const isErrorRoute = this.pathname === '/404' || this.pathname === '/_error';\n    try {\n      var _self___NEXT_DATA___props_pageProps, _self___NEXT_DATA___props, _routeInfo_props;\n      let routeInfo = await this.getRouteInfo({\n        route,\n        pathname,\n        query,\n        as,\n        resolvedAs,\n        routeProps,\n        locale: nextState.locale,\n        isPreview: nextState.isPreview,\n        hasMiddleware: isMiddlewareMatch,\n        unstable_skipClientCache: options.unstable_skipClientCache,\n        isQueryUpdating: isQueryUpdating && !this.isFallback,\n        isMiddlewareRewrite\n      });\n      if (!isQueryUpdating && !options.shallow) {\n        await this._bfl(as, 'resolvedAs' in routeInfo ? routeInfo.resolvedAs : undefined, nextState.locale);\n      }\n      if ('route' in routeInfo && isMiddlewareMatch) {\n        pathname = routeInfo.route || route;\n        route = pathname;\n        if (!routeProps.shallow) {\n          query = Object.assign({}, routeInfo.query || {}, query);\n        }\n        const cleanedParsedPathname = (0, _hasbasepath.hasBasePath)(parsed.pathname) ? (0, _removebasepath.removeBasePath)(parsed.pathname) : parsed.pathname;\n        if (routeMatch && pathname !== cleanedParsedPathname) {\n          Object.keys(routeMatch).forEach(key => {\n            if (routeMatch && query[key] === routeMatch[key]) {\n              delete query[key];\n            }\n          });\n        }\n        if ((0, _isdynamic.isDynamicRoute)(pathname)) {\n          const prefixedAs = !routeProps.shallow && routeInfo.resolvedAs ? routeInfo.resolvedAs : (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(new URL(as, location.href).pathname, nextState.locale), true);\n          let rewriteAs = prefixedAs;\n          if ((0, _hasbasepath.hasBasePath)(rewriteAs)) {\n            rewriteAs = (0, _removebasepath.removeBasePath)(rewriteAs);\n          }\n          if (false) {}\n          const routeRegex = (0, _routeregex.getRouteRegex)(pathname);\n          const curRouteMatch = (0, _routematcher.getRouteMatcher)(routeRegex)(new URL(rewriteAs, location.href).pathname);\n          if (curRouteMatch) {\n            Object.assign(query, curRouteMatch);\n          }\n        }\n      }\n      // If the routeInfo brings a redirect we simply apply it.\n      if ('type' in routeInfo) {\n        if (routeInfo.type === 'redirect-internal') {\n          return this.change(method, routeInfo.newUrl, routeInfo.newAs, options);\n        } else {\n          handleHardNavigation({\n            url: routeInfo.destination,\n            router: this\n          });\n          return new Promise(() => {});\n        }\n      }\n      const component = routeInfo.Component;\n      if (component && component.unstable_scriptLoader) {\n        const scripts = [].concat(component.unstable_scriptLoader());\n        scripts.forEach(script => {\n          (0, _script.handleClientScriptLoad)(script.props);\n        });\n      }\n      // handle redirect on client-transition\n      if ((routeInfo.__N_SSG || routeInfo.__N_SSP) && routeInfo.props) {\n        if (routeInfo.props.pageProps && routeInfo.props.pageProps.__N_REDIRECT) {\n          // Use the destination from redirect without adding locale\n          options.locale = false;\n          const destination = routeInfo.props.pageProps.__N_REDIRECT;\n          // check if destination is internal (resolves to a page) and attempt\n          // client-navigation if it is falling back to hard navigation if\n          // it's not\n          if (destination.startsWith('/') && routeInfo.props.pageProps.__N_REDIRECT_BASE_PATH !== false) {\n            const parsedHref = (0, _parserelativeurl.parseRelativeUrl)(destination);\n            parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n            const {\n              url: newUrl,\n              as: newAs\n            } = prepareUrlAs(this, destination, destination);\n            return this.change(method, newUrl, newAs, options);\n          }\n          handleHardNavigation({\n            url: destination,\n            router: this\n          });\n          return new Promise(() => {});\n        }\n        nextState.isPreview = !!routeInfo.props.__N_PREVIEW;\n        // handle SSG data 404\n        if (routeInfo.props.notFound === SSG_DATA_NOT_FOUND) {\n          let notFoundRoute;\n          try {\n            await this.fetchComponent('/404');\n            notFoundRoute = '/404';\n          } catch (_) {\n            notFoundRoute = '/_error';\n          }\n          routeInfo = await this.getRouteInfo({\n            route: notFoundRoute,\n            pathname: notFoundRoute,\n            query,\n            as,\n            resolvedAs,\n            routeProps: {\n              shallow: false\n            },\n            locale: nextState.locale,\n            isPreview: nextState.isPreview,\n            isNotFound: true\n          });\n          if ('type' in routeInfo) {\n            throw Object.defineProperty(new Error(\"Unexpected middleware effect on /404\"), \"__NEXT_ERROR_CODE\", {\n              value: \"E158\",\n              enumerable: false,\n              configurable: true\n            });\n          }\n        }\n      }\n      if (isQueryUpdating && this.pathname === '/_error' && ((_self___NEXT_DATA___props = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps = _self___NEXT_DATA___props.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps.statusCode) === 500 && ((_routeInfo_props = routeInfo.props) == null ? void 0 : _routeInfo_props.pageProps)) {\n        // ensure statusCode is still correct for static 500 page\n        // when updating query information\n        routeInfo.props.pageProps.statusCode = 500;\n      }\n      var _routeInfo_route;\n      // shallow routing is only allowed for same page URL changes.\n      const isValidShallowRoute = options.shallow && nextState.route === ((_routeInfo_route = routeInfo.route) != null ? _routeInfo_route : route);\n      var _options_scroll;\n      const shouldScroll = (_options_scroll = options.scroll) != null ? _options_scroll : !isQueryUpdating && !isValidShallowRoute;\n      const resetScroll = shouldScroll ? {\n        x: 0,\n        y: 0\n      } : null;\n      const upcomingScrollState = forcedScroll != null ? forcedScroll : resetScroll;\n      // the new state that the router gonna set\n      const upcomingRouterState = {\n        ...nextState,\n        route,\n        pathname,\n        query,\n        asPath: cleanedAs,\n        isFallback: false\n      };\n      // When the page being rendered is the 404 page, we should only update the\n      // query parameters. Route changes here might add the basePath when it\n      // wasn't originally present. This is also why this block is before the\n      // below `changeState` call which updates the browser's history (changing\n      // the URL).\n      if (isQueryUpdating && isErrorRoute) {\n        var _self___NEXT_DATA___props_pageProps1, _self___NEXT_DATA___props1, _routeInfo_props1;\n        routeInfo = await this.getRouteInfo({\n          route: this.pathname,\n          pathname: this.pathname,\n          query,\n          as,\n          resolvedAs,\n          routeProps: {\n            shallow: false\n          },\n          locale: nextState.locale,\n          isPreview: nextState.isPreview,\n          isQueryUpdating: isQueryUpdating && !this.isFallback\n        });\n        if ('type' in routeInfo) {\n          throw Object.defineProperty(new Error(\"Unexpected middleware effect on \" + this.pathname), \"__NEXT_ERROR_CODE\", {\n            value: \"E225\",\n            enumerable: false,\n            configurable: true\n          });\n        }\n        if (this.pathname === '/_error' && ((_self___NEXT_DATA___props1 = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps1 = _self___NEXT_DATA___props1.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps1.statusCode) === 500 && ((_routeInfo_props1 = routeInfo.props) == null ? void 0 : _routeInfo_props1.pageProps)) {\n          // ensure statusCode is still correct for static 500 page\n          // when updating query information\n          routeInfo.props.pageProps.statusCode = 500;\n        }\n        try {\n          await this.set(upcomingRouterState, routeInfo, upcomingScrollState);\n        } catch (err) {\n          if ((0, _iserror.default)(err) && err.cancelled) {\n            Router.events.emit('routeChangeError', err, cleanedAs, routeProps);\n          }\n          throw err;\n        }\n        return true;\n      }\n      Router.events.emit('beforeHistoryChange', as, routeProps);\n      this.changeState(method, url, as, options);\n      // for query updates we can skip it if the state is unchanged and we don't\n      // need to scroll\n      // https://github.com/vercel/next.js/issues/37139\n      const canSkipUpdating = isQueryUpdating && !upcomingScrollState && !readyStateChange && !localeChange && (0, _comparestates.compareRouterStates)(upcomingRouterState, this.state);\n      if (!canSkipUpdating) {\n        try {\n          await this.set(upcomingRouterState, routeInfo, upcomingScrollState);\n        } catch (e) {\n          if (e.cancelled) routeInfo.error = routeInfo.error || e;else throw e;\n        }\n        if (routeInfo.error) {\n          if (!isQueryUpdating) {\n            Router.events.emit('routeChangeError', routeInfo.error, cleanedAs, routeProps);\n          }\n          throw routeInfo.error;\n        }\n        if (false) {}\n        if (!isQueryUpdating) {\n          Router.events.emit('routeChangeComplete', as, routeProps);\n        }\n        // A hash mark # is the optional last part of a URL\n        const hashRegex = /#.+$/;\n        if (shouldScroll && hashRegex.test(as)) {\n          this.scrollToHash(as);\n        }\n      }\n      return true;\n    } catch (err) {\n      if ((0, _iserror.default)(err) && err.cancelled) {\n        return false;\n      }\n      throw err;\n    }\n  }\n  changeState(method, url, as, options) {\n    if (options === void 0) options = {};\n    if (true) {\n      if (typeof window.history === 'undefined') {\n        console.error(\"Warning: window.history is not available.\");\n        return;\n      }\n      if (typeof window.history[method] === 'undefined') {\n        console.error(\"Warning: window.history.\" + method + \" is not available\");\n        return;\n      }\n    }\n    if (method !== 'pushState' || (0, _utils.getURL)() !== as) {\n      this._shallow = options.shallow;\n      window.history[method]({\n        url,\n        as,\n        options,\n        __N: true,\n        key: this._key = method !== 'pushState' ? this._key : createKey()\n      },\n      // Most browsers currently ignores this parameter, although they may use it in the future.\n      // Passing the empty string here should be safe against future changes to the method.\n      // https://developer.mozilla.org/docs/Web/API/History/replaceState\n      '', as);\n    }\n  }\n  async handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {\n    if (err.cancelled) {\n      // bubble up cancellation errors\n      throw err;\n    }\n    if ((0, _routeloader.isAssetError)(err) || loadErrorFail) {\n      Router.events.emit('routeChangeError', err, as, routeProps);\n      // If we can't load the page it could be one of following reasons\n      //  1. Page doesn't exists\n      //  2. Page does exist in a different zone\n      //  3. Internal error while loading the page\n      // So, doing a hard reload is the proper way to deal with this.\n      handleHardNavigation({\n        url: as,\n        router: this\n      });\n      // Changing the URL doesn't block executing the current code path.\n      // So let's throw a cancellation error stop the routing logic.\n      throw buildCancellationError();\n    }\n    console.error(err);\n    try {\n      let props;\n      const {\n        page: Component,\n        styleSheets\n      } = await this.fetchComponent('/_error');\n      const routeInfo = {\n        props,\n        Component,\n        styleSheets,\n        err,\n        error: err\n      };\n      if (!routeInfo.props) {\n        try {\n          routeInfo.props = await this.getInitialProps(Component, {\n            err,\n            pathname,\n            query\n          });\n        } catch (gipErr) {\n          console.error('Error in error page `getInitialProps`: ', gipErr);\n          routeInfo.props = {};\n        }\n      }\n      return routeInfo;\n    } catch (routeInfoErr) {\n      return this.handleRouteInfoError((0, _iserror.default)(routeInfoErr) ? routeInfoErr : Object.defineProperty(new Error(routeInfoErr + ''), \"__NEXT_ERROR_CODE\", {\n        value: \"E394\",\n        enumerable: false,\n        configurable: true\n      }), pathname, query, as, routeProps, true);\n    }\n  }\n  async getRouteInfo(param) {\n    let {\n      route: requestedRoute,\n      pathname,\n      query,\n      as,\n      resolvedAs,\n      routeProps,\n      locale,\n      hasMiddleware,\n      isPreview,\n      unstable_skipClientCache,\n      isQueryUpdating,\n      isMiddlewareRewrite,\n      isNotFound\n    } = param;\n    /**\n    * This `route` binding can change if there's a rewrite\n    * so we keep a reference to the original requested route\n    * so we can store the cache for it and avoid re-requesting every time\n    * for shallow routing purposes.\n    */\n    let route = requestedRoute;\n    try {\n      var _data_effect, _data_effect1, _data_effect2, _data_response;\n      let existingInfo = this.components[route];\n      if (routeProps.shallow && existingInfo && this.route === route) {\n        return existingInfo;\n      }\n      const handleCancelled = getCancelledHandler({\n        route,\n        router: this\n      });\n      if (hasMiddleware) {\n        existingInfo = undefined;\n      }\n      let cachedRouteInfo = existingInfo && !('initial' in existingInfo) && false ? 0 : undefined;\n      const isBackground = isQueryUpdating;\n      const fetchNextDataParams = {\n        dataHref: this.pageLoader.getDataHref({\n          href: (0, _formaturl.formatWithValidation)({\n            pathname,\n            query\n          }),\n          skipInterpolation: true,\n          asPath: isNotFound ? '/404' : resolvedAs,\n          locale\n        }),\n        hasMiddleware: true,\n        isServerRender: this.isSsr,\n        parseJSON: true,\n        inflightCache: isBackground ? this.sbc : this.sdc,\n        persistCache: !isPreview,\n        isPrefetch: false,\n        unstable_skipClientCache,\n        isBackground\n      };\n      let data = isQueryUpdating && !isMiddlewareRewrite ? null : await withMiddlewareEffects({\n        fetchData: () => fetchNextData(fetchNextDataParams),\n        asPath: isNotFound ? '/404' : resolvedAs,\n        locale: locale,\n        router: this\n      }).catch(err => {\n        // we don't hard error during query updating\n        // as it's un-necessary and doesn't need to be fatal\n        // unless it is a fallback route and the props can't\n        // be loaded\n        if (isQueryUpdating) {\n          return null;\n        }\n        throw err;\n      });\n      // when rendering error routes we don't apply middleware\n      // effects\n      if (data && (pathname === '/_error' || pathname === '/404')) {\n        data.effect = undefined;\n      }\n      if (isQueryUpdating) {\n        if (!data) {\n          data = {\n            json: self.__NEXT_DATA__.props\n          };\n        } else {\n          data.json = self.__NEXT_DATA__.props;\n        }\n      }\n      handleCancelled();\n      if ((data == null ? void 0 : (_data_effect = data.effect) == null ? void 0 : _data_effect.type) === 'redirect-internal' || (data == null ? void 0 : (_data_effect1 = data.effect) == null ? void 0 : _data_effect1.type) === 'redirect-external') {\n        return data.effect;\n      }\n      if ((data == null ? void 0 : (_data_effect2 = data.effect) == null ? void 0 : _data_effect2.type) === 'rewrite') {\n        const resolvedRoute = (0, _removetrailingslash.removeTrailingSlash)(data.effect.resolvedHref);\n        const pages = await this.pageLoader.getPageList();\n        // during query updating the page must match although during\n        // client-transition a redirect that doesn't match a page\n        // can be returned and this should trigger a hard navigation\n        // which is valid for incremental migration\n        if (!isQueryUpdating || pages.includes(resolvedRoute)) {\n          route = resolvedRoute;\n          pathname = data.effect.resolvedHref;\n          query = {\n            ...query,\n            ...data.effect.parsedAs.query\n          };\n          resolvedAs = (0, _removebasepath.removeBasePath)((0, _normalizelocalepath.normalizeLocalePath)(data.effect.parsedAs.pathname, this.locales).pathname);\n          // Check again the cache with the new destination.\n          existingInfo = this.components[route];\n          if (routeProps.shallow && existingInfo && this.route === route && !hasMiddleware) {\n            // If we have a match with the current route due to rewrite,\n            // we can copy the existing information to the rewritten one.\n            // Then, we return the information along with the matched route.\n            return {\n              ...existingInfo,\n              route\n            };\n          }\n        }\n      }\n      if ((0, _isapiroute.isAPIRoute)(route)) {\n        handleHardNavigation({\n          url: as,\n          router: this\n        });\n        return new Promise(() => {});\n      }\n      const routeInfo = cachedRouteInfo || (await this.fetchComponent(route).then(res => ({\n        Component: res.page,\n        styleSheets: res.styleSheets,\n        __N_SSG: res.mod.__N_SSG,\n        __N_SSP: res.mod.__N_SSP\n      })));\n      if (true) {\n        const {\n          isValidElementType\n        } = __webpack_require__(/*! next/dist/compiled/react-is */ \"(pages-dir-browser)/./node_modules/next/dist/compiled/react-is/index.js\");\n        if (!isValidElementType(routeInfo.Component)) {\n          throw Object.defineProperty(new Error('The default export is not a React Component in page: \"' + pathname + '\"'), \"__NEXT_ERROR_CODE\", {\n            value: \"E286\",\n            enumerable: false,\n            configurable: true\n          });\n        }\n      }\n      const wasBailedPrefetch = data == null ? void 0 : (_data_response = data.response) == null ? void 0 : _data_response.headers.get('x-middleware-skip');\n      const shouldFetchData = routeInfo.__N_SSG || routeInfo.__N_SSP;\n      // For non-SSG prefetches that bailed before sending data\n      // we clear the cache to fetch full response\n      if (wasBailedPrefetch && (data == null ? void 0 : data.dataHref)) {\n        delete this.sdc[data.dataHref];\n      }\n      const {\n        props,\n        cacheKey\n      } = await this._getData(async () => {\n        if (shouldFetchData) {\n          if ((data == null ? void 0 : data.json) && !wasBailedPrefetch) {\n            return {\n              cacheKey: data.cacheKey,\n              props: data.json\n            };\n          }\n          const dataHref = (data == null ? void 0 : data.dataHref) ? data.dataHref : this.pageLoader.getDataHref({\n            href: (0, _formaturl.formatWithValidation)({\n              pathname,\n              query\n            }),\n            asPath: resolvedAs,\n            locale\n          });\n          const fetched = await fetchNextData({\n            dataHref,\n            isServerRender: this.isSsr,\n            parseJSON: true,\n            inflightCache: wasBailedPrefetch ? {} : this.sdc,\n            persistCache: !isPreview,\n            isPrefetch: false,\n            unstable_skipClientCache\n          });\n          return {\n            cacheKey: fetched.cacheKey,\n            props: fetched.json || {}\n          };\n        }\n        return {\n          headers: {},\n          props: await this.getInitialProps(routeInfo.Component,\n          // we provide AppTree later so this needs to be `any`\n          {\n            pathname,\n            query,\n            asPath: as,\n            locale,\n            locales: this.locales,\n            defaultLocale: this.defaultLocale\n          })\n        };\n      });\n      // Only bust the data cache for SSP routes although\n      // middleware can skip cache per request with\n      // x-middleware-cache: no-cache as well\n      if (routeInfo.__N_SSP && fetchNextDataParams.dataHref && cacheKey) {\n        delete this.sdc[cacheKey];\n      }\n      // we kick off a HEAD request in the background\n      // when a non-prefetch request is made to signal revalidation\n      if (!this.isPreview && routeInfo.__N_SSG && false && 0) {}\n      props.pageProps = Object.assign({}, props.pageProps);\n      routeInfo.props = props;\n      routeInfo.route = route;\n      routeInfo.query = query;\n      routeInfo.resolvedAs = resolvedAs;\n      this.components[route] = routeInfo;\n      return routeInfo;\n    } catch (err) {\n      return this.handleRouteInfoError((0, _iserror.getProperError)(err), pathname, query, as, routeProps);\n    }\n  }\n  set(state, data, resetScroll) {\n    this.state = state;\n    return this.sub(data, this.components['/_app'].Component, resetScroll);\n  }\n  /**\n  * Callback to execute before replacing router state\n  * @param cb callback to be executed\n  */\n  beforePopState(cb) {\n    this._bps = cb;\n  }\n  onlyAHashChange(as) {\n    if (!this.asPath) return false;\n    const [oldUrlNoHash, oldHash] = this.asPath.split('#', 2);\n    const [newUrlNoHash, newHash] = as.split('#', 2);\n    // Makes sure we scroll to the provided hash if the url/hash are the same\n    if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n      return true;\n    }\n    // If the urls are change, there's more than a hash change\n    if (oldUrlNoHash !== newUrlNoHash) {\n      return false;\n    }\n    // If the hash has changed, then it's a hash only change.\n    // This check is necessary to handle both the enter and\n    // leave hash === '' cases. The identity case falls through\n    // and is treated as a next reload.\n    return oldHash !== newHash;\n  }\n  scrollToHash(as) {\n    const [, hash = ''] = as.split('#', 2);\n    (0, _handlesmoothscroll.handleSmoothScroll)(() => {\n      // Scroll to top if the hash is just `#` with no value or `#top`\n      // To mirror browsers\n      if (hash === '' || hash === 'top') {\n        window.scrollTo(0, 0);\n        return;\n      }\n      // Decode hash to make non-latin anchor works.\n      const rawHash = decodeURIComponent(hash);\n      // First we check if the element by id is found\n      const idEl = document.getElementById(rawHash);\n      if (idEl) {\n        idEl.scrollIntoView();\n        return;\n      }\n      // If there's no element with the id, we check the `name` property\n      // To mirror browsers\n      const nameEl = document.getElementsByName(rawHash)[0];\n      if (nameEl) {\n        nameEl.scrollIntoView();\n      }\n    }, {\n      onlyHashChange: this.onlyAHashChange(as)\n    });\n  }\n  urlIsNew(asPath) {\n    return this.asPath !== asPath;\n  }\n  /**\n  * Prefetch page code, you may wait for the data during page rendering.\n  * This feature only works in production!\n  * @param url the href of prefetched page\n  * @param asPath the as path of the prefetched page\n  */\n  async prefetch(url, asPath, options) {\n    if (asPath === void 0) asPath = url;\n    if (options === void 0) options = {};\n    // Prefetch is not supported in development mode because it would trigger on-demand-entries\n    if (true) {\n      return;\n    }\n    if ( true && (0, _isbot.isBot)(window.navigator.userAgent)) {\n      // No prefetches for bots that render the link since they are typically navigating\n      // links via the equivalent of a hard navigation and hence never utilize these\n      // prefetches.\n      return;\n    }\n    let parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n    const urlPathname = parsed.pathname;\n    let {\n      pathname,\n      query\n    } = parsed;\n    const originalPathname = pathname;\n    if (false) {}\n    const pages = await this.pageLoader.getPageList();\n    let resolvedAs = asPath;\n    const locale = typeof options.locale !== 'undefined' ? options.locale || undefined : this.locale;\n    const isMiddlewareMatch = await matchesMiddleware({\n      asPath: asPath,\n      locale: locale,\n      router: this\n    });\n    if (false) {}\n    parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n    if ((0, _isdynamic.isDynamicRoute)(parsed.pathname)) {\n      pathname = parsed.pathname;\n      parsed.pathname = pathname;\n      Object.assign(query, (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(parsed.pathname))((0, _parsepath.parsePath)(asPath).pathname) || {});\n      if (!isMiddlewareMatch) {\n        url = (0, _formaturl.formatWithValidation)(parsed);\n      }\n    }\n    const data =  false ? 0 : await withMiddlewareEffects({\n      fetchData: () => fetchNextData({\n        dataHref: this.pageLoader.getDataHref({\n          href: (0, _formaturl.formatWithValidation)({\n            pathname: originalPathname,\n            query\n          }),\n          skipInterpolation: true,\n          asPath: resolvedAs,\n          locale\n        }),\n        hasMiddleware: true,\n        isServerRender: false,\n        parseJSON: true,\n        inflightCache: this.sdc,\n        persistCache: !this.isPreview,\n        isPrefetch: true\n      }),\n      asPath: asPath,\n      locale: locale,\n      router: this\n    });\n    /**\n    * If there was a rewrite we apply the effects of the rewrite on the\n    * current parameters for the prefetch.\n    */\n    if ((data == null ? void 0 : data.effect.type) === 'rewrite') {\n      parsed.pathname = data.effect.resolvedHref;\n      pathname = data.effect.resolvedHref;\n      query = {\n        ...query,\n        ...data.effect.parsedAs.query\n      };\n      resolvedAs = data.effect.parsedAs.pathname;\n      url = (0, _formaturl.formatWithValidation)(parsed);\n    }\n    /**\n    * If there is a redirect to an external destination then we don't have\n    * to prefetch content as it will be unused.\n    */\n    if ((data == null ? void 0 : data.effect.type) === 'redirect-external') {\n      return;\n    }\n    const route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n    if (await this._bfl(asPath, resolvedAs, options.locale, true)) {\n      this.components[urlPathname] = {\n        __appRouter: true\n      };\n    }\n    await Promise.all([this.pageLoader._isSsg(route).then(isSsg => {\n      return isSsg ? fetchNextData({\n        dataHref: (data == null ? void 0 : data.json) ? data == null ? void 0 : data.dataHref : this.pageLoader.getDataHref({\n          href: url,\n          asPath: resolvedAs,\n          locale: locale\n        }),\n        isServerRender: false,\n        parseJSON: true,\n        inflightCache: this.sdc,\n        persistCache: !this.isPreview,\n        isPrefetch: true,\n        unstable_skipClientCache: options.unstable_skipClientCache || options.priority && !!true\n      }).then(() => false).catch(() => false) : false;\n    }), this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route)]);\n  }\n  async fetchComponent(route) {\n    const handleCancelled = getCancelledHandler({\n      route,\n      router: this\n    });\n    try {\n      const componentResult = await this.pageLoader.loadPage(route);\n      handleCancelled();\n      return componentResult;\n    } catch (err) {\n      handleCancelled();\n      throw err;\n    }\n  }\n  _getData(fn) {\n    let cancelled = false;\n    const cancel = () => {\n      cancelled = true;\n    };\n    this.clc = cancel;\n    return fn().then(data => {\n      if (cancel === this.clc) {\n        this.clc = null;\n      }\n      if (cancelled) {\n        const err = Object.defineProperty(new Error('Loading initial props cancelled'), \"__NEXT_ERROR_CODE\", {\n          value: \"E405\",\n          enumerable: false,\n          configurable: true\n        });\n        err.cancelled = true;\n        throw err;\n      }\n      return data;\n    });\n  }\n  getInitialProps(Component, ctx) {\n    const {\n      Component: App\n    } = this.components['/_app'];\n    const AppTree = this._wrapApp(App);\n    ctx.AppTree = AppTree;\n    return (0, _utils.loadGetInitialProps)(App, {\n      AppTree,\n      Component,\n      router: this,\n      ctx\n    });\n  }\n  get route() {\n    return this.state.route;\n  }\n  get pathname() {\n    return this.state.pathname;\n  }\n  get query() {\n    return this.state.query;\n  }\n  get asPath() {\n    return this.state.asPath;\n  }\n  get locale() {\n    return this.state.locale;\n  }\n  get isFallback() {\n    return this.state.isFallback;\n  }\n  get isPreview() {\n    return this.state.isPreview;\n  }\n  constructor(pathname, query, as, {\n    initialProps,\n    pageLoader,\n    App,\n    wrapApp,\n    Component,\n    err,\n    subscription,\n    isFallback,\n    locale,\n    locales,\n    defaultLocale,\n    domainLocales,\n    isPreview\n  }) {\n    // Server Data Cache (full data requests)\n    this.sdc = {};\n    // Server Background Cache (HEAD requests)\n    this.sbc = {};\n    this.isFirstPopStateEvent = true;\n    this._key = createKey();\n    this.onPopState = e => {\n      const {\n        isFirstPopStateEvent\n      } = this;\n      this.isFirstPopStateEvent = false;\n      const state = e.state;\n      if (!state) {\n        // We get state as undefined for two reasons.\n        //  1. With older safari (< 8) and older chrome (< 34)\n        //  2. When the URL changed with #\n        //\n        // In the both cases, we don't need to proceed and change the route.\n        // (as it's already changed)\n        // But we can simply replace the state with the new changes.\n        // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n        // So, doing the following for (1) does no harm.\n        const {\n          pathname,\n          query\n        } = this;\n        this.changeState('replaceState', (0, _formaturl.formatWithValidation)({\n          pathname: (0, _addbasepath.addBasePath)(pathname),\n          query\n        }), (0, _utils.getURL)());\n        return;\n      }\n      // __NA is used to identify if the history entry can be handled by the app-router.\n      if (state.__NA) {\n        window.location.reload();\n        return;\n      }\n      if (!state.__N) {\n        return;\n      }\n      // Safari fires popstateevent when reopening the browser.\n      if (isFirstPopStateEvent && this.locale === state.options.locale && state.as === this.asPath) {\n        return;\n      }\n      let forcedScroll;\n      const {\n        url,\n        as,\n        options,\n        key\n      } = state;\n      if (false) {}\n      this._key = key;\n      const {\n        pathname\n      } = (0, _parserelativeurl.parseRelativeUrl)(url);\n      // Make sure we don't re-render on initial load,\n      // can be caused by navigating back from an external site\n      if (this.isSsr && as === (0, _addbasepath.addBasePath)(this.asPath) && pathname === (0, _addbasepath.addBasePath)(this.pathname)) {\n        return;\n      }\n      // If the downstream application returns falsy, return.\n      // They will then be responsible for handling the event.\n      if (this._bps && !this._bps(state)) {\n        return;\n      }\n      this.change('replaceState', url, as, Object.assign({}, options, {\n        shallow: options.shallow && this._shallow,\n        locale: options.locale || this.defaultLocale,\n        // @ts-ignore internal value not exposed on types\n        _h: 0\n      }), forcedScroll);\n    };\n    // represents the current component key\n    const route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n    // set up the component cache (by route keys)\n    this.components = {};\n    // We should not keep the cache, if there's an error\n    // Otherwise, this cause issues when when going back and\n    // come again to the errored page.\n    if (pathname !== '/_error') {\n      this.components[route] = {\n        Component,\n        initial: true,\n        props: initialProps,\n        err,\n        __N_SSG: initialProps && initialProps.__N_SSG,\n        __N_SSP: initialProps && initialProps.__N_SSP\n      };\n    }\n    this.components['/_app'] = {\n      Component: App,\n      styleSheets: []\n    };\n    // Backwards compat for Router.router.events\n    // TODO: Should be remove the following major version as it was never documented\n    this.events = Router.events;\n    this.pageLoader = pageLoader;\n    // if auto prerendered and dynamic route wait to update asPath\n    // until after mount to prevent hydration mismatch\n    const autoExportDynamic = (0, _isdynamic.isDynamicRoute)(pathname) && self.__NEXT_DATA__.autoExport;\n    this.basePath =  false || '';\n    this.sub = subscription;\n    this.clc = null;\n    this._wrapApp = wrapApp;\n    // make sure to ignore extra popState in safari on navigating\n    // back from external site\n    this.isSsr = true;\n    this.isLocaleDomain = false;\n    this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.isExperimentalCompile || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !false);\n    if (false) {}\n    this.state = {\n      route,\n      pathname,\n      query,\n      asPath: autoExportDynamic ? pathname : as,\n      isPreview: !!isPreview,\n      locale:  false ? 0 : undefined,\n      isFallback\n    };\n    this._initialMatchesMiddlewarePromise = Promise.resolve(false);\n    if (true) {\n      // make sure \"as\" doesn't start with double slashes or else it can\n      // throw an error as it's considered invalid\n      if (!as.startsWith('//')) {\n        // in order for `e.state` to work on the `onpopstate` event\n        // we have to register the initial route upon initialization\n        const options = {\n          locale\n        };\n        const asPath = (0, _utils.getURL)();\n        this._initialMatchesMiddlewarePromise = matchesMiddleware({\n          router: this,\n          locale,\n          asPath\n        }).then(matches => {\n          // if middleware matches we leave resolving to the change function\n          // as the server needs to resolve for correct priority\n          ;\n          options._shouldResolveHref = as !== pathname;\n          this.changeState('replaceState', matches ? asPath : (0, _formaturl.formatWithValidation)({\n            pathname: (0, _addbasepath.addBasePath)(pathname),\n            query\n          }), asPath, options);\n          return matches;\n        });\n      }\n      window.addEventListener('popstate', this.onPopState);\n      // enable custom scroll restoration handling when available\n      // otherwise fallback to browser's default handling\n      if (false) {}\n    }\n  }\n}\nRouter.events = (0, _mitt.default)();\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvcm91dGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ2E7O0FBQ2JBLDhDQUE2QztFQUN6Q0csS0FBSyxFQUFFO0FBQ1gsQ0FBQyxFQUFDO0FBQ0YsQ0FBQyxLQUFLQyxDQUlMLENBQUM7QUFDRixTQUFTSSxPQUFPQSxDQUFDQyxNQUFNLEVBQUVDLEdBQUcsRUFBRTtFQUMxQixLQUFJLElBQUlDLElBQUksSUFBSUQsR0FBRyxFQUFDVixNQUFNLENBQUNDLGNBQWMsQ0FBQ1EsTUFBTSxFQUFFRSxJQUFJLEVBQUU7SUFDcERDLFVBQVUsRUFBRSxJQUFJO0lBQ2hCQyxHQUFHLEVBQUVILEdBQUcsQ0FBQ0MsSUFBSTtFQUNqQixDQUFDLENBQUM7QUFDTjtBQUNBSCxPQUFPLENBQUNOLE9BQU8sRUFBRTtFQUNiRyxTQUFTLEVBQUUsU0FBQUEsQ0FBQSxFQUFXO0lBQ2xCLE9BQU9BLFNBQVM7RUFDcEIsQ0FBQztFQUNEQyxPQUFPLEVBQUUsU0FBQUEsQ0FBQSxFQUFXO0lBQ2hCLE9BQU9RLE1BQU07RUFDakIsQ0FBQztFQUNEUCxpQkFBaUIsRUFBRSxTQUFBQSxDQUFBLEVBQVc7SUFDMUIsT0FBT0EsaUJBQWlCO0VBQzVCO0FBQ0osQ0FBQyxDQUFDO0FBQ0YsTUFBTVEsd0JBQXdCLEdBQUdDLG1CQUFPLENBQUMsZ0lBQXlDLENBQUM7QUFDbkYsTUFBTUMseUJBQXlCLEdBQUdELG1CQUFPLENBQUMsa0lBQTBDLENBQUM7QUFDckYsTUFBTUUsb0JBQW9CLEdBQUdGLG1CQUFPLENBQUMsb0lBQStCLENBQUM7QUFDckUsTUFBTUcsWUFBWSxHQUFHSCxtQkFBTyxDQUFDLHlHQUE4QixDQUFDO0FBQzVELE1BQU1JLE9BQU8sR0FBR0osbUJBQU8sQ0FBQyw2RkFBd0IsQ0FBQztBQUNqRCxNQUFNSyxRQUFRLEdBQUcsYUFBY0oseUJBQXlCLENBQUNLLENBQUMsQ0FBQ04s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VSxDQUFDK1Asb0JBQW9CLEVBQUU7WUFDckZoTyxRQUFRLEVBQUUsQ0FBQyxDQUFDLEVBQUV6QixZQUFZLENBQUNpQyxXQUFXLEVBQUVSLFFBQVEsQ0FBQztZQUNqRDZFO1VBQ0osQ0FBQyxDQUFDLEVBQUUxRSxNQUFNLEVBQUVWLE9BQU8sQ0FBQztVQUNwQixPQUFPeUYsT0FBTztRQUNsQixDQUFDLENBQUM7TUFDTjtNQUNBc0IsTUFBTSxDQUFDa1QsZ0JBQWdCLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQ2QsVUFBVSxDQUFDO01BQ3BEO01BQ0E7TUFDQSxJQUFJelYsS0FBcUMsRUFBRSxFQUkxQztJQUNMO0VBQ0o7QUFDSjtBQUNBcEcsTUFBTSxDQUFDa1MsTUFBTSxHQUFHLENBQUMsQ0FBQyxFQUFFdlIsS0FBSyxDQUFDbkIsT0FBTyxFQUFFLENBQUMiLCJzb3VyY2VzIjpbIi9wcm9qZWN0L3NhbmRib3gvdXNlci13b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci9yb3V0ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdHNsaW50OmRpc2FibGU6bm8tY29uc29sZVxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBjcmVhdGVLZXk6IG51bGwsXG4gICAgZGVmYXVsdDogbnVsbCxcbiAgICBtYXRjaGVzTWlkZGxld2FyZTogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBjcmVhdGVLZXk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlS2V5O1xuICAgIH0sXG4gICAgZGVmYXVsdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBSb3V0ZXI7XG4gICAgfSxcbiAgICBtYXRjaGVzTWlkZGxld2FyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVzTWlkZGxld2FyZTtcbiAgICB9XG59KTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHRcIik7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9fL19pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmRcIik7XG5jb25zdCBfcmVtb3ZldHJhaWxpbmdzbGFzaCA9IHJlcXVpcmUoXCIuL3V0aWxzL3JlbW92ZS10cmFpbGluZy1zbGFzaFwiKTtcbmNvbnN0IF9yb3V0ZWxvYWRlciA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvcm91dGUtbG9hZGVyXCIpO1xuY29uc3QgX3NjcmlwdCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvc2NyaXB0XCIpO1xuY29uc3QgX2lzZXJyb3IgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQuXyhyZXF1aXJlKFwiLi4vLi4vLi4vbGliL2lzLWVycm9yXCIpKTtcbmNvbnN0IF9kZW5vcm1hbGl6ZXBhZ2VwYXRoID0gcmVxdWlyZShcIi4uL3BhZ2UtcGF0aC9kZW5vcm1hbGl6ZS1wYWdlLXBhdGhcIik7XG5jb25zdCBfbm9ybWFsaXplbG9jYWxlcGF0aCA9IHJlcXVpcmUoXCIuLi9pMThuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aFwiKTtcbmNvbnN0IF9taXR0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwiLi4vbWl0dFwiKSk7XG5jb25zdCBfdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5jb25zdCBfaXNkeW5hbWljID0gcmVxdWlyZShcIi4vdXRpbHMvaXMtZHluYW1pY1wiKTtcbmNvbnN0IF9wYXJzZXJlbGF0aXZldXJsID0gcmVxdWlyZShcIi4vdXRpbHMvcGFyc2UtcmVsYXRpdmUtdXJsXCIpO1xuY29uc3QgX3Jlc29sdmVyZXdyaXRlcyA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcIi4vdXRpbHMvcmVzb2x2ZS1yZXdyaXRlc1wiKSk7XG5jb25zdCBfcm91dGVtYXRjaGVyID0gcmVxdWlyZShcIi4vdXRpbHMvcm91dGUtbWF0Y2hlclwiKTtcbmNvbnN0IF9yb3V0ZXJlZ2V4ID0gcmVxdWlyZShcIi4vdXRpbHMvcm91dGUtcmVnZXhcIik7XG5jb25zdCBfZm9ybWF0dXJsID0gcmVxdWlyZShcIi4vdXRpbHMvZm9ybWF0LXVybFwiKTtcbmNvbnN0IF9kZXRlY3Rkb21haW5sb2NhbGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L2RldGVjdC1kb21haW4tbG9jYWxlXCIpO1xuY29uc3QgX3BhcnNlcGF0aCA9IHJlcXVpcmUoXCIuL3V0aWxzL3BhcnNlLXBhdGhcIik7XG5jb25zdCBfYWRkbG9jYWxlID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9hZGQtbG9jYWxlXCIpO1xuY29uc3QgX3JlbW92ZWxvY2FsZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvcmVtb3ZlLWxvY2FsZVwiKTtcbmNvbnN0IF9yZW1vdmViYXNlcGF0aCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvcmVtb3ZlLWJhc2UtcGF0aFwiKTtcbmNvbnN0IF9hZGRiYXNlcGF0aCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvYWRkLWJhc2UtcGF0aFwiKTtcbmNvbnN0IF9oYXNiYXNlcGF0aCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvaGFzLWJhc2UtcGF0aFwiKTtcbmNvbnN0IF9yZXNvbHZlaHJlZiA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvcmVzb2x2ZS1ocmVmXCIpO1xuY29uc3QgX2lzYXBpcm91dGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vbGliL2lzLWFwaS1yb3V0ZVwiKTtcbmNvbnN0IF9nZXRuZXh0cGF0aG5hbWVpbmZvID0gcmVxdWlyZShcIi4vdXRpbHMvZ2V0LW5leHQtcGF0aG5hbWUtaW5mb1wiKTtcbmNvbnN0IF9mb3JtYXRuZXh0cGF0aG5hbWVpbmZvID0gcmVxdWlyZShcIi4vdXRpbHMvZm9ybWF0LW5leHQtcGF0aG5hbWUtaW5mb1wiKTtcbmNvbnN0IF9jb21wYXJlc3RhdGVzID0gcmVxdWlyZShcIi4vdXRpbHMvY29tcGFyZS1zdGF0ZXNcIik7XG5jb25zdCBfaXNsb2NhbHVybCA9IHJlcXVpcmUoXCIuL3V0aWxzL2lzLWxvY2FsLXVybFwiKTtcbmNvbnN0IF9pc2JvdCA9IHJlcXVpcmUoXCIuL3V0aWxzL2lzLWJvdFwiKTtcbmNvbnN0IF9vbWl0ID0gcmVxdWlyZShcIi4vdXRpbHMvb21pdFwiKTtcbmNvbnN0IF9pbnRlcnBvbGF0ZWFzID0gcmVxdWlyZShcIi4vdXRpbHMvaW50ZXJwb2xhdGUtYXNcIik7XG5jb25zdCBfaGFuZGxlc21vb3Roc2Nyb2xsID0gcmVxdWlyZShcIi4vdXRpbHMvaGFuZGxlLXNtb290aC1zY3JvbGxcIik7XG5jb25zdCBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL2xpYi9jb25zdGFudHNcIik7XG5mdW5jdGlvbiBidWlsZENhbmNlbGxhdGlvbkVycm9yKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXcgRXJyb3IoJ1JvdXRlIENhbmNlbGxlZCcpLCBcIl9fTkVYVF9FUlJPUl9DT0RFXCIsIHtcbiAgICAgICAgdmFsdWU6IFwiRTMxNVwiLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSksIHtcbiAgICAgICAgY2FuY2VsbGVkOiB0cnVlXG4gICAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBtYXRjaGVzTWlkZGxld2FyZShvcHRpb25zKSB7XG4gICAgY29uc3QgbWF0Y2hlcnMgPSBhd2FpdCBQcm9taXNlLnJlc29sdmUob3B0aW9ucy5yb3V0ZXIucGFnZUxvYWRlci5nZXRNaWRkbGV3YXJlKCkpO1xuICAgIGlmICghbWF0Y2hlcnMpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCB7IHBhdGhuYW1lOiBhc1BhdGhuYW1lIH0gPSAoMCwgX3BhcnNlcGF0aC5wYXJzZVBhdGgpKG9wdGlvbnMuYXNQYXRoKTtcbiAgICAvLyByZW1vdmUgYmFzZVBhdGggZmlyc3Qgc2luY2UgcGF0aCBwcmVmaXggaGFzIHRvIGJlIGluIHRoZSBvcmRlciBvZiBgLyR7YmFzZVBhdGh9LyR7bG9jYWxlfWBcbiAgICBjb25zdCBjbGVhbmVkQXMgPSAoMCwgX2hhc2Jhc2VwYXRoLmhhc0Jhc2VQYXRoKShhc1BhdGhuYW1lKSA/ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKGFzUGF0aG5hbWUpIDogYXNQYXRobmFtZTtcbiAgICBjb25zdCBhc1dpdGhCYXNlUGF0aEFuZExvY2FsZSA9ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKCgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkoY2xlYW5lZEFzLCBvcHRpb25zLmxvY2FsZSkpO1xuICAgIC8vIENoZWNrIG9ubHkgcGF0aCBtYXRjaCBvbiBjbGllbnQuIE1hdGNoaW5nIFwiaGFzXCIgc2hvdWxkIGJlIGRvbmUgb24gc2VydmVyXG4gICAgLy8gd2hlcmUgd2UgY2FuIGFjY2VzcyBtb3JlIGluZm8gc3VjaCBhcyBoZWFkZXJzLCBIdHRwT25seSBjb29raWUsIGV0Yy5cbiAgICByZXR1cm4gbWF0Y2hlcnMuc29tZSgobSk9Pm5ldyBSZWdFeHAobS5yZWdleHApLnRlc3QoYXNXaXRoQmFzZVBhdGhBbmRMb2NhbGUpKTtcbn1cbmZ1bmN0aW9uIHN0cmlwT3JpZ2luKHVybCkge1xuICAgIGNvbnN0IG9yaWdpbiA9ICgwLCBfdXRpbHMuZ2V0TG9jYXRpb25PcmlnaW4pKCk7XG4gICAgcmV0dXJuIHVybC5zdGFydHNXaXRoKG9yaWdpbikgPyB1cmwuc3Vic3RyaW5nKG9yaWdpbi5sZW5ndGgpIDogdXJsO1xufVxuZnVuY3Rpb24gcHJlcGFyZVVybEFzKHJvdXRlciwgdXJsLCBhcykge1xuICAgIC8vIElmIHVybCBhbmQgYXMgcHJvdmlkZWQgYXMgYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uLFxuICAgIC8vIHdlJ2xsIGZvcm1hdCB0aGVtIGludG8gdGhlIHN0cmluZyB2ZXJzaW9uIGhlcmUuXG4gICAgbGV0IFtyZXNvbHZlZEhyZWYsIHJlc29sdmVkQXNdID0gKDAsIF9yZXNvbHZlaHJlZi5yZXNvbHZlSHJlZikocm91dGVyLCB1cmwsIHRydWUpO1xuICAgIGNvbnN0IG9yaWdpbiA9ICgwLCBfdXRpbHMuZ2V0TG9jYXRpb25PcmlnaW4pKCk7XG4gICAgY29uc3QgaHJlZldhc0Fic29sdXRlID0gcmVzb2x2ZWRIcmVmLnN0YXJ0c1dpdGgob3JpZ2luKTtcbiAgICBjb25zdCBhc1dhc0Fic29sdXRlID0gcmVzb2x2ZWRBcyAmJiByZXNvbHZlZEFzLnN0YXJ0c1dpdGgob3JpZ2luKTtcbiAgICByZXNvbHZlZEhyZWYgPSBzdHJpcE9yaWdpbihyZXNvbHZlZEhyZWYpO1xuICAgIHJlc29sdmVkQXMgPSByZXNvbHZlZEFzID8gc3RyaXBPcmlnaW4ocmVzb2x2ZWRBcykgOiByZXNvbHZlZEFzO1xuICAgIGNvbnN0IHByZXBhcmVkVXJsID0gaHJlZldhc0Fic29sdXRlID8gcmVzb2x2ZWRIcmVmIDogKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkocmVzb2x2ZWRIcmVmKTtcbiAgICBjb25zdCBwcmVwYXJlZEFzID0gYXMgPyBzdHJpcE9yaWdpbigoMCwgX3Jlc29sdmVocmVmLnJlc29sdmVIcmVmKShyb3V0ZXIsIGFzKSkgOiByZXNvbHZlZEFzIHx8IHJlc29sdmVkSHJlZjtcbiAgICByZXR1cm4ge1xuICAgICAgICB1cmw6IHByZXBhcmVkVXJsLFxuICAgICAgICBhczogYXNXYXNBYnNvbHV0ZSA/IHByZXBhcmVkQXMgOiAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKShwcmVwYXJlZEFzKVxuICAgIH07XG59XG5mdW5jdGlvbiByZXNvbHZlRHluYW1pY1JvdXRlKHBhdGhuYW1lLCBwYWdlcykge1xuICAgIGNvbnN0IGNsZWFuUGF0aG5hbWUgPSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkoKDAsIF9kZW5vcm1hbGl6ZXBhZ2VwYXRoLmRlbm9ybWFsaXplUGFnZVBhdGgpKHBhdGhuYW1lKSk7XG4gICAgaWYgKGNsZWFuUGF0aG5hbWUgPT09ICcvNDA0JyB8fCBjbGVhblBhdGhuYW1lID09PSAnL19lcnJvcicpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhuYW1lO1xuICAgIH1cbiAgICAvLyBoYW5kbGUgcmVzb2x2aW5nIGhyZWYgZm9yIGR5bmFtaWMgcm91dGVzXG4gICAgaWYgKCFwYWdlcy5pbmNsdWRlcyhjbGVhblBhdGhuYW1lKSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYXJyYXktY2FsbGJhY2stcmV0dXJuXG4gICAgICAgIHBhZ2VzLnNvbWUoKHBhZ2UpPT57XG4gICAgICAgICAgICBpZiAoKDAsIF9pc2R5bmFtaWMuaXNEeW5hbWljUm91dGUpKHBhZ2UpICYmICgwLCBfcm91dGVyZWdleC5nZXRSb3V0ZVJlZ2V4KShwYWdlKS5yZS50ZXN0KGNsZWFuUGF0aG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcGF0aG5hbWUgPSBwYWdlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShwYXRobmFtZSk7XG59XG5mdW5jdGlvbiBnZXRNaWRkbGV3YXJlRGF0YShzb3VyY2UsIHJlc3BvbnNlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbmV4dENvbmZpZyA9IHtcbiAgICAgICAgYmFzZVBhdGg6IG9wdGlvbnMucm91dGVyLmJhc2VQYXRoLFxuICAgICAgICBpMThuOiB7XG4gICAgICAgICAgICBsb2NhbGVzOiBvcHRpb25zLnJvdXRlci5sb2NhbGVzXG4gICAgICAgIH0sXG4gICAgICAgIHRyYWlsaW5nU2xhc2g6IEJvb2xlYW4ocHJvY2Vzcy5lbnYuX19ORVhUX1RSQUlMSU5HX1NMQVNIKVxuICAgIH07XG4gICAgY29uc3QgcmV3cml0ZUhlYWRlciA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCd4LW5leHRqcy1yZXdyaXRlJyk7XG4gICAgbGV0IHJld3JpdGVUYXJnZXQgPSByZXdyaXRlSGVhZGVyIHx8IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCd4LW5leHRqcy1tYXRjaGVkLXBhdGgnKTtcbiAgICBjb25zdCBtYXRjaGVkUGF0aCA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KF9jb25zdGFudHMuTUFUQ0hFRF9QQVRIX0hFQURFUik7XG4gICAgaWYgKG1hdGNoZWRQYXRoICYmICFyZXdyaXRlVGFyZ2V0ICYmICFtYXRjaGVkUGF0aC5pbmNsdWRlcygnX19uZXh0X2RhdGFfY2F0Y2hhbGwnKSAmJiAhbWF0Y2hlZFBhdGguaW5jbHVkZXMoJy9fZXJyb3InKSAmJiAhbWF0Y2hlZFBhdGguaW5jbHVkZXMoJy80MDQnKSkge1xuICAgICAgICAvLyBsZXZlcmFnZSB4LW1hdGNoZWQtcGF0aCB0byBkZXRlY3QgbmV4dC5jb25maWcuanMgcmV3cml0ZXNcbiAgICAgICAgcmV3cml0ZVRhcmdldCA9IG1hdGNoZWRQYXRoO1xuICAgIH1cbiAgICBpZiAocmV3cml0ZVRhcmdldCkge1xuICAgICAgICBpZiAocmV3cml0ZVRhcmdldC5zdGFydHNXaXRoKCcvJykgfHwgcHJvY2Vzcy5lbnYuX19ORVhUX0VYVEVSTkFMX01JRERMRVdBUkVfUkVXUklURV9SRVNPTFZFKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRSZXdyaXRlVGFyZ2V0ID0gKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKHJld3JpdGVUYXJnZXQpO1xuICAgICAgICAgICAgY29uc3QgcGF0aG5hbWVJbmZvID0gKDAsIF9nZXRuZXh0cGF0aG5hbWVpbmZvLmdldE5leHRQYXRobmFtZUluZm8pKHBhcnNlZFJld3JpdGVUYXJnZXQucGF0aG5hbWUsIHtcbiAgICAgICAgICAgICAgICBuZXh0Q29uZmlnLFxuICAgICAgICAgICAgICAgIHBhcnNlRGF0YTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgZnNQYXRobmFtZSA9ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShwYXRobmFtZUluZm8ucGF0aG5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnJvdXRlci5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KCksXG4gICAgICAgICAgICAgICAgKDAsIF9yb3V0ZWxvYWRlci5nZXRDbGllbnRCdWlsZE1hbmlmZXN0KSgpXG4gICAgICAgICAgICBdKS50aGVuKChwYXJhbSk9PntcbiAgICAgICAgICAgICAgICBsZXQgW3BhZ2VzLCB7IF9fcmV3cml0ZXM6IHJld3JpdGVzIH1dID0gcGFyYW07XG4gICAgICAgICAgICAgICAgbGV0IGFzID0gKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKShwYXRobmFtZUluZm8ucGF0aG5hbWUsIHBhdGhuYW1lSW5mby5sb2NhbGUpO1xuICAgICAgICAgICAgICAgIGlmICgoMCwgX2lzZHluYW1pYy5pc0R5bmFtaWNSb3V0ZSkoYXMpIHx8ICFyZXdyaXRlSGVhZGVyICYmIHBhZ2VzLmluY2x1ZGVzKCgwLCBfbm9ybWFsaXplbG9jYWxlcGF0aC5ub3JtYWxpemVMb2NhbGVQYXRoKSgoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShhcyksIG9wdGlvbnMucm91dGVyLmxvY2FsZXMpLnBhdGhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRTb3VyY2UgPSAoMCwgX2dldG5leHRwYXRobmFtZWluZm8uZ2V0TmV4dFBhdGhuYW1lSW5mbykoKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKHNvdXJjZSkucGF0aG5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRDb25maWc6IHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMgPyB1bmRlZmluZWQgOiBuZXh0Q29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VEYXRhOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBhcyA9ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHBhcnNlZFNvdXJjZS5wYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZFJld3JpdGVUYXJnZXQucGF0aG5hbWUgPSBhcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gKDAsIF9yZXNvbHZlcmV3cml0ZXMuZGVmYXVsdCkoYXMsIHBhZ2VzLCByZXdyaXRlcywgcGFyc2VkUmV3cml0ZVRhcmdldC5xdWVyeSwgKHBhdGgpPT5yZXNvbHZlRHluYW1pY1JvdXRlKHBhdGgsIHBhZ2VzKSwgb3B0aW9ucy5yb3V0ZXIubG9jYWxlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubWF0Y2hlZFBhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZFJld3JpdGVUYXJnZXQucGF0aG5hbWUgPSByZXN1bHQucGFyc2VkQXMucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcyA9IHBhcnNlZFJld3JpdGVUYXJnZXQucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHBhcnNlZFJld3JpdGVUYXJnZXQucXVlcnksIHJlc3VsdC5wYXJzZWRBcy5xdWVyeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFwYWdlcy5pbmNsdWRlcyhmc1BhdGhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlZFBhdGhuYW1lID0gcmVzb2x2ZUR5bmFtaWNSb3V0ZShmc1BhdGhuYW1lLCBwYWdlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZFBhdGhuYW1lICE9PSBmc1BhdGhuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmc1BhdGhuYW1lID0gcmVzb2x2ZWRQYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlZEhyZWYgPSAhcGFnZXMuaW5jbHVkZXMoZnNQYXRobmFtZSkgPyByZXNvbHZlRHluYW1pY1JvdXRlKCgwLCBfbm9ybWFsaXplbG9jYWxlcGF0aC5ub3JtYWxpemVMb2NhbGVQYXRoKSgoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShwYXJzZWRSZXdyaXRlVGFyZ2V0LnBhdGhuYW1lKSwgb3B0aW9ucy5yb3V0ZXIubG9jYWxlcykucGF0aG5hbWUsIHBhZ2VzKSA6IGZzUGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlKShyZXNvbHZlZEhyZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSAoMCwgX3JvdXRlbWF0Y2hlci5nZXRSb3V0ZU1hdGNoZXIpKCgwLCBfcm91dGVyZWdleC5nZXRSb3V0ZVJlZ2V4KShyZXNvbHZlZEhyZWYpKShhcyk7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocGFyc2VkUmV3cml0ZVRhcmdldC5xdWVyeSwgbWF0Y2hlcyB8fCB7fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdyZXdyaXRlJyxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkQXM6IHBhcnNlZFJld3JpdGVUYXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkSHJlZlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcmMgPSAoMCwgX3BhcnNlcGF0aC5wYXJzZVBhdGgpKHNvdXJjZSk7XG4gICAgICAgIGNvbnN0IHBhdGhuYW1lID0gKDAsIF9mb3JtYXRuZXh0cGF0aG5hbWVpbmZvLmZvcm1hdE5leHRQYXRobmFtZUluZm8pKHtcbiAgICAgICAgICAgIC4uLigwLCBfZ2V0bmV4dHBhdGhuYW1laW5mby5nZXROZXh0UGF0aG5hbWVJbmZvKShzcmMucGF0aG5hbWUsIHtcbiAgICAgICAgICAgICAgICBuZXh0Q29uZmlnLFxuICAgICAgICAgICAgICAgIHBhcnNlRGF0YTogdHJ1ZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBkZWZhdWx0TG9jYWxlOiBvcHRpb25zLnJvdXRlci5kZWZhdWx0TG9jYWxlLFxuICAgICAgICAgICAgYnVpbGRJZDogJydcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgdHlwZTogJ3JlZGlyZWN0LWV4dGVybmFsJyxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uOiBcIlwiICsgcGF0aG5hbWUgKyBzcmMucXVlcnkgKyBzcmMuaGFzaFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcmVkaXJlY3RUYXJnZXQgPSByZXNwb25zZS5oZWFkZXJzLmdldCgneC1uZXh0anMtcmVkaXJlY3QnKTtcbiAgICBpZiAocmVkaXJlY3RUYXJnZXQpIHtcbiAgICAgICAgaWYgKHJlZGlyZWN0VGFyZ2V0LnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgY29uc3Qgc3JjID0gKDAsIF9wYXJzZXBhdGgucGFyc2VQYXRoKShyZWRpcmVjdFRhcmdldCk7XG4gICAgICAgICAgICBjb25zdCBwYXRobmFtZSA9ICgwLCBfZm9ybWF0bmV4dHBhdGhuYW1laW5mby5mb3JtYXROZXh0UGF0aG5hbWVJbmZvKSh7XG4gICAgICAgICAgICAgICAgLi4uKDAsIF9nZXRuZXh0cGF0aG5hbWVpbmZvLmdldE5leHRQYXRobmFtZUluZm8pKHNyYy5wYXRobmFtZSwge1xuICAgICAgICAgICAgICAgICAgICBuZXh0Q29uZmlnLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZURhdGE6IHRydWVcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0TG9jYWxlOiBvcHRpb25zLnJvdXRlci5kZWZhdWx0TG9jYWxlLFxuICAgICAgICAgICAgICAgIGJ1aWxkSWQ6ICcnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdyZWRpcmVjdC1pbnRlcm5hbCcsXG4gICAgICAgICAgICAgICAgbmV3QXM6IFwiXCIgKyBwYXRobmFtZSArIHNyYy5xdWVyeSArIHNyYy5oYXNoLFxuICAgICAgICAgICAgICAgIG5ld1VybDogXCJcIiArIHBhdGhuYW1lICsgc3JjLnF1ZXJ5ICsgc3JjLmhhc2hcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgdHlwZTogJ3JlZGlyZWN0LWV4dGVybmFsJyxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uOiByZWRpcmVjdFRhcmdldFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgIHR5cGU6ICduZXh0J1xuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gd2l0aE1pZGRsZXdhcmVFZmZlY3RzKG9wdGlvbnMpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gYXdhaXQgbWF0Y2hlc01pZGRsZXdhcmUob3B0aW9ucyk7XG4gICAgaWYgKCFtYXRjaGVzIHx8ICFvcHRpb25zLmZldGNoRGF0YSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IG9wdGlvbnMuZmV0Y2hEYXRhKCk7XG4gICAgY29uc3QgZWZmZWN0ID0gYXdhaXQgZ2V0TWlkZGxld2FyZURhdGEoZGF0YS5kYXRhSHJlZiwgZGF0YS5yZXNwb25zZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YUhyZWY6IGRhdGEuZGF0YUhyZWYsXG4gICAgICAgIGpzb246IGRhdGEuanNvbixcbiAgICAgICAgcmVzcG9uc2U6IGRhdGEucmVzcG9uc2UsXG4gICAgICAgIHRleHQ6IGRhdGEudGV4dCxcbiAgICAgICAgY2FjaGVLZXk6IGRhdGEuY2FjaGVLZXksXG4gICAgICAgIGVmZmVjdFxuICAgIH07XG59XG5jb25zdCBtYW51YWxTY3JvbGxSZXN0b3JhdGlvbiA9IHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04gJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ3Njcm9sbFJlc3RvcmF0aW9uJyBpbiB3aW5kb3cuaGlzdG9yeSAmJiAhIWZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGxldCB2ID0gJ19fbmV4dCc7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZXF1ZW5jZXNcbiAgICAgICAgcmV0dXJuIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0odiwgdiksIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0odiksIHRydWU7XG4gICAgfSBjYXRjaCAobikge31cbn0oKTtcbmNvbnN0IFNTR19EQVRBX05PVF9GT1VORCA9IFN5bWJvbCgnU1NHX0RBVEFfTk9UX0ZPVU5EJyk7XG5mdW5jdGlvbiBmZXRjaFJldHJ5KHVybCwgYXR0ZW1wdHMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZmV0Y2godXJsLCB7XG4gICAgICAgIC8vIENvb2tpZXMgYXJlIHJlcXVpcmVkIHRvIGJlIHByZXNlbnQgZm9yIE5leHQuanMnIFNTRyBcIlByZXZpZXcgTW9kZVwiLlxuICAgICAgICAvLyBDb29raWVzIG1heSBhbHNvIGJlIHJlcXVpcmVkIGZvciBgZ2V0U2VydmVyU2lkZVByb3BzYC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gPiBgZmV0Y2hgIHdvbuKAmXQgc2VuZCBjb29raWVzLCB1bmxlc3MgeW91IHNldCB0aGUgY3JlZGVudGlhbHMgaW5pdFxuICAgICAgICAvLyA+IG9wdGlvbi5cbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0ZldGNoX0FQSS9Vc2luZ19GZXRjaFxuICAgICAgICAvL1xuICAgICAgICAvLyA+IEZvciBtYXhpbXVtIGJyb3dzZXIgY29tcGF0aWJpbGl0eSB3aGVuIGl0IGNvbWVzIHRvIHNlbmRpbmcgJlxuICAgICAgICAvLyA+IHJlY2VpdmluZyBjb29raWVzLCBhbHdheXMgc3VwcGx5IHRoZSBgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbidgXG4gICAgICAgIC8vID4gb3B0aW9uIGluc3RlYWQgb2YgcmVseWluZyBvbiB0aGUgZGVmYXVsdC5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dpdGh1Yi9mZXRjaCNjYXZlYXRzXG4gICAgICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nLFxuICAgICAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kIHx8ICdHRVQnLFxuICAgICAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLmhlYWRlcnMsIHtcbiAgICAgICAgICAgICd4LW5leHRqcy1kYXRhJzogJzEnXG4gICAgICAgIH0pXG4gICAgfSkudGhlbigocmVzcG9uc2UpPT57XG4gICAgICAgIHJldHVybiAhcmVzcG9uc2Uub2sgJiYgYXR0ZW1wdHMgPiAxICYmIHJlc3BvbnNlLnN0YXR1cyA+PSA1MDAgPyBmZXRjaFJldHJ5KHVybCwgYXR0ZW1wdHMgLSAxLCBvcHRpb25zKSA6IHJlc3BvbnNlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gdHJ5VG9QYXJzZUFzSlNPTih0ZXh0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGV4dCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gZmV0Y2hOZXh0RGF0YShwYXJhbSkge1xuICAgIGxldCB7IGRhdGFIcmVmLCBpbmZsaWdodENhY2hlLCBpc1ByZWZldGNoLCBoYXNNaWRkbGV3YXJlLCBpc1NlcnZlclJlbmRlciwgcGFyc2VKU09OLCBwZXJzaXN0Q2FjaGUsIGlzQmFja2dyb3VuZCwgdW5zdGFibGVfc2tpcENsaWVudENhY2hlIH0gPSBwYXJhbTtcbiAgICBjb25zdCB7IGhyZWY6IGNhY2hlS2V5IH0gPSBuZXcgVVJMKGRhdGFIcmVmLCB3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgY29uc3QgZ2V0RGF0YSA9IChwYXJhbXMpPT57XG4gICAgICAgIHZhciBfcGFyYW1zX21ldGhvZDtcbiAgICAgICAgcmV0dXJuIGZldGNoUmV0cnkoZGF0YUhyZWYsIGlzU2VydmVyUmVuZGVyID8gMyA6IDEsIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe30sIGlzUHJlZmV0Y2ggPyB7XG4gICAgICAgICAgICAgICAgcHVycG9zZTogJ3ByZWZldGNoJ1xuICAgICAgICAgICAgfSA6IHt9LCBpc1ByZWZldGNoICYmIGhhc01pZGRsZXdhcmUgPyB7XG4gICAgICAgICAgICAgICAgJ3gtbWlkZGxld2FyZS1wcmVmZXRjaCc6ICcxJ1xuICAgICAgICAgICAgfSA6IHt9LCBwcm9jZXNzLmVudi5ORVhUX0RFUExPWU1FTlRfSUQgPyB7XG4gICAgICAgICAgICAgICAgJ3gtZGVwbG95bWVudC1pZCc6IHByb2Nlc3MuZW52Lk5FWFRfREVQTE9ZTUVOVF9JRFxuICAgICAgICAgICAgfSA6IHt9KSxcbiAgICAgICAgICAgIG1ldGhvZDogKF9wYXJhbXNfbWV0aG9kID0gcGFyYW1zID09IG51bGwgPyB2b2lkIDAgOiBwYXJhbXMubWV0aG9kKSAhPSBudWxsID8gX3BhcmFtc19tZXRob2QgOiAnR0VUJ1xuICAgICAgICB9KS50aGVuKChyZXNwb25zZSk9PntcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5vayAmJiAocGFyYW1zID09IG51bGwgPyB2b2lkIDAgOiBwYXJhbXMubWV0aG9kKSA9PT0gJ0hFQUQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWYsXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnJyxcbiAgICAgICAgICAgICAgICAgICAganNvbjoge30sXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCkudGhlbigodGV4dCk9PntcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2hlbiB0aGUgZGF0YSByZXNwb25zZSBpcyBhIHJlZGlyZWN0IGJlY2F1c2Ugb2YgYSBtaWRkbGV3YXJlXG4gICAgICAgICAgICAgKiB3ZSBkbyBub3QgY29uc2lkZXIgaXQgYW4gZXJyb3IuIFRoZSBoZWFkZXJzIG11c3QgYnJpbmcgdGhlXG4gICAgICAgICAgICAgKiBtYXBwZWQgbG9jYXRpb24uXG4gICAgICAgICAgICAgKiBUT0RPOiBDaGFuZ2UgdGhlIHN0YXR1cyBjb2RlIGluIHRoZSBoYW5kbGVyLlxuICAgICAgICAgICAgICovIGlmIChoYXNNaWRkbGV3YXJlICYmIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIDMwMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDMwMixcbiAgICAgICAgICAgICAgICAgICAgICAgIDMwNyxcbiAgICAgICAgICAgICAgICAgICAgICAgIDMwOFxuICAgICAgICAgICAgICAgICAgICBdLmluY2x1ZGVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUtleVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfdHJ5VG9QYXJzZUFzSlNPTjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX3RyeVRvUGFyc2VBc0pTT04gPSB0cnlUb1BhcnNlQXNKU09OKHRleHQpKSA9PSBudWxsID8gdm9pZCAwIDogX3RyeVRvUGFyc2VBc0pTT04ubm90Rm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90Rm91bmQ6IFNTR19EQVRBX05PVF9GT1VORFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ldyBFcnJvcihcIkZhaWxlZCB0byBsb2FkIHN0YXRpYyBwcm9wc1wiKSwgXCJfX05FWFRfRVJST1JfQ09ERVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCJFMTI0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXZSBzaG91bGQgb25seSB0cmlnZ2VyIGEgc2VydmVyLXNpZGUgdHJhbnNpdGlvbiBpZiB0aGlzIHdhc1xuICAgICAgICAgICAgICogY2F1c2VkIG9uIGEgY2xpZW50LXNpZGUgdHJhbnNpdGlvbi4gT3RoZXJ3aXNlLCB3ZSdkIGdldCBpbnRvXG4gICAgICAgICAgICAgKiBhbiBpbmZpbml0ZSBsb29wLlxuICAgICAgICAgICAgICovIGlmICghaXNTZXJ2ZXJSZW5kZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfcm91dGVsb2FkZXIubWFya0Fzc2V0RXJyb3IpKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWYsXG4gICAgICAgICAgICAgICAgICAgIGpzb246IHBhcnNlSlNPTiA/IHRyeVRvUGFyc2VBc0pTT04odGV4dCkgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLnRoZW4oKGRhdGEpPT57XG4gICAgICAgICAgICBpZiAoIXBlcnNpc3RDYWNoZSB8fCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nIHx8IGRhdGEucmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtbWlkZGxld2FyZS1jYWNoZScpID09PSAnbm8tY2FjaGUnKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICAgICAgICBpZiAoIXVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBpbmZsaWdodENhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgvLyBjaHJvbWVcbiAgICAgICAgICAgIGVyci5tZXNzYWdlID09PSAnRmFpbGVkIHRvIGZldGNoJyB8fCAvLyBmaXJlZm94XG4gICAgICAgICAgICBlcnIubWVzc2FnZSA9PT0gJ05ldHdvcmtFcnJvciB3aGVuIGF0dGVtcHRpbmcgdG8gZmV0Y2ggcmVzb3VyY2UuJyB8fCAvLyBzYWZhcmlcbiAgICAgICAgICAgIGVyci5tZXNzYWdlID09PSAnTG9hZCBmYWlsZWQnKSB7XG4gICAgICAgICAgICAgICAgKDAsIF9yb3V0ZWxvYWRlci5tYXJrQXNzZXRFcnJvcikoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyB3aGVuIHNraXBwaW5nIGNsaWVudCBjYWNoZSB3ZSB3YWl0IHRvIHVwZGF0ZVxuICAgIC8vIGluZmxpZ2h0IGNhY2hlIHVudGlsIHN1Y2Nlc3NmdWwgZGF0YSByZXNwb25zZVxuICAgIC8vIHRoaXMgYWxsb3dzIHJhY2luZyBjbGljayBldmVudCB3aXRoIGZldGNoaW5nIG5ld2VyIGRhdGFcbiAgICAvLyB3aXRob3V0IGJsb2NraW5nIG5hdmlnYXRpb24gd2hlbiBzdGFsZSBkYXRhIGlzIGF2YWlsYWJsZVxuICAgIGlmICh1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUgJiYgcGVyc2lzdENhY2hlKSB7XG4gICAgICAgIHJldHVybiBnZXREYXRhKHt9KS50aGVuKChkYXRhKT0+e1xuICAgICAgICAgICAgaWYgKGRhdGEucmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtbWlkZGxld2FyZS1jYWNoZScpICE9PSAnbm8tY2FjaGUnKSB7XG4gICAgICAgICAgICAgICAgLy8gb25seSB1cGRhdGUgY2FjaGUgaWYgbm90IG1hcmtlZCBhcyBuby1jYWNoZVxuICAgICAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldID0gUHJvbWlzZS5yZXNvbHZlKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaW5mbGlnaHRDYWNoZVtjYWNoZUtleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gaW5mbGlnaHRDYWNoZVtjYWNoZUtleV07XG4gICAgfVxuICAgIHJldHVybiBpbmZsaWdodENhY2hlW2NhY2hlS2V5XSA9IGdldERhdGEoaXNCYWNrZ3JvdW5kID8ge1xuICAgICAgICBtZXRob2Q6ICdIRUFEJ1xuICAgIH0gOiB7fSk7XG59XG5mdW5jdGlvbiBjcmVhdGVLZXkoKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIsIDEwKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHBhcmFtKSB7XG4gICAgbGV0IHsgdXJsLCByb3V0ZXIgfSA9IHBhcmFtO1xuICAgIC8vIGVuc3VyZSB3ZSBkb24ndCB0cmlnZ2VyIGEgaGFyZCBuYXZpZ2F0aW9uIHRvIHRoZSBzYW1lXG4gICAgLy8gVVJMIGFzIHRoaXMgY2FuIGVuZCB1cCB3aXRoIGFuIGluZmluaXRlIHJlZnJlc2hcbiAgICBpZiAodXJsID09PSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKHJvdXRlci5hc1BhdGgsIHJvdXRlci5sb2NhbGUpKSkge1xuICAgICAgICB0aHJvdyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3IEVycm9yKFwiSW52YXJpYW50OiBhdHRlbXB0ZWQgdG8gaGFyZCBuYXZpZ2F0ZSB0byB0aGUgc2FtZSBVUkwgXCIgKyB1cmwgKyBcIiBcIiArIGxvY2F0aW9uLmhyZWYpLCBcIl9fTkVYVF9FUlJPUl9DT0RFXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiBcIkUyODJcIixcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybDtcbn1cbmNvbnN0IGdldENhbmNlbGxlZEhhbmRsZXIgPSAocGFyYW0pPT57XG4gICAgbGV0IHsgcm91dGUsIHJvdXRlciB9ID0gcGFyYW07XG4gICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGNhbmNlbCA9IHJvdXRlci5jbGMgPSAoKT0+e1xuICAgICAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgIH07XG4gICAgY29uc3QgaGFuZGxlQ2FuY2VsbGVkID0gKCk9PntcbiAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3IEVycm9yKCdBYm9ydCBmZXRjaGluZyBjb21wb25lbnQgZm9yIHJvdXRlOiBcIicgKyByb3V0ZSArICdcIicpLCBcIl9fTkVYVF9FUlJPUl9DT0RFXCIsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJFNDgzXCIsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGVycm9yLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FuY2VsID09PSByb3V0ZXIuY2xjKSB7XG4gICAgICAgICAgICByb3V0ZXIuY2xjID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGhhbmRsZUNhbmNlbGxlZDtcbn07XG5jbGFzcyBSb3V0ZXIge1xuICAgIHJlbG9hZCgpIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICogR28gYmFjayBpbiBoaXN0b3J5XG4gICAqLyBiYWNrKCkge1xuICAgICAgICB3aW5kb3cuaGlzdG9yeS5iYWNrKCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBHbyBmb3J3YXJkIGluIGhpc3RvcnlcbiAgICovIGZvcndhcmQoKSB7XG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LmZvcndhcmQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFBlcmZvcm1zIGEgYHB1c2hTdGF0ZWAgd2l0aCBhcmd1bWVudHNcbiAgICogQHBhcmFtIHVybCBvZiB0aGUgcm91dGVcbiAgICogQHBhcmFtIGFzIG1hc2tzIGB1cmxgIGZvciB0aGUgYnJvd3NlclxuICAgKiBAcGFyYW0gb3B0aW9ucyBvYmplY3QgeW91IGNhbiBkZWZpbmUgYHNoYWxsb3dgIGFuZCBvdGhlciBvcHRpb25zXG4gICAqLyBwdXNoKHVybCwgYXMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgb3B0aW9ucyA9IHt9O1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVtb3ZlIGluIHRoZSBmdXR1cmUgd2hlbiB3ZSB1cGRhdGUgaGlzdG9yeSBiZWZvcmUgcm91dGUgY2hhbmdlXG4gICAgICAgICAgICAvLyBpcyBjb21wbGV0ZSwgYXMgdGhlIHBvcHN0YXRlIGV2ZW50IHNob3VsZCBoYW5kbGUgdGhpcyBjYXB0dXJlLlxuICAgICAgICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU25hcHNob3Qgc2Nyb2xsIHBvc2l0aW9uIHJpZ2h0IGJlZm9yZSBuYXZpZ2F0aW5nIHRvIGEgbmV3IHBhZ2U6XG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oJ19fbmV4dF9zY3JvbGxfJyArIHRoaXMuX2tleSwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogc2VsZi5wYWdlWE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHNlbGYucGFnZVlPZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICAoeyB1cmwsIGFzIH0gPSBwcmVwYXJlVXJsQXModGhpcywgdXJsLCBhcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2UoJ3B1c2hTdGF0ZScsIHVybCwgYXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICogUGVyZm9ybXMgYSBgcmVwbGFjZVN0YXRlYCB3aXRoIGFyZ3VtZW50c1xuICAgKiBAcGFyYW0gdXJsIG9mIHRoZSByb3V0ZVxuICAgKiBAcGFyYW0gYXMgbWFza3MgYHVybGAgZm9yIHRoZSBicm93c2VyXG4gICAqIEBwYXJhbSBvcHRpb25zIG9iamVjdCB5b3UgY2FuIGRlZmluZSBgc2hhbGxvd2AgYW5kIG90aGVyIG9wdGlvbnNcbiAgICovIHJlcGxhY2UodXJsLCBhcywgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSBvcHRpb25zID0ge307XG4gICAgICAgIDtcbiAgICAgICAgKHsgdXJsLCBhcyB9ID0gcHJlcGFyZVVybEFzKHRoaXMsIHVybCwgYXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlKCdyZXBsYWNlU3RhdGUnLCB1cmwsIGFzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgX2JmbChhcywgcmVzb2x2ZWRBcywgbG9jYWxlLCBza2lwTmF2aWdhdGUpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfUk9VVEVSX0ZJTFRFUl9FTkFCTEVEKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2JmbF9zICYmICF0aGlzLl9iZmxfZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgQmxvb21GaWx0ZXIgfSA9IHJlcXVpcmUoJy4uLy4uL2xpYi9ibG9vbS1maWx0ZXInKTtcbiAgICAgICAgICAgICAgICBsZXQgc3RhdGljRmlsdGVyRGF0YTtcbiAgICAgICAgICAgICAgICBsZXQgZHluYW1pY0ZpbHRlckRhdGE7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICAoeyBfX3JvdXRlckZpbHRlclN0YXRpYzogc3RhdGljRmlsdGVyRGF0YSwgX19yb3V0ZXJGaWx0ZXJEeW5hbWljOiBkeW5hbWljRmlsdGVyRGF0YSB9ID0gYXdhaXQgKDAsIF9yb3V0ZWxvYWRlci5nZXRDbGllbnRCdWlsZE1hbmlmZXN0KSgpKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmFpbGVkIHRvIGxvYWQgYnVpbGQgbWFuaWZlc3QgaGFyZCBuYXZpZ2F0ZVxuICAgICAgICAgICAgICAgICAgICAvLyB0byBiZSBzYWZlXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNraXBOYXZpZ2F0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKGFzLCBsb2NhbGUgfHwgdGhpcy5sb2NhbGUsIHRoaXMuZGVmYXVsdExvY2FsZSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCk9Pnt9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgcm91dGVyRmlsdGVyU1ZhbHVlID0gcHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9ST1VURVJfU19GSUxURVI7XG4gICAgICAgICAgICAgICAgaWYgKCFzdGF0aWNGaWx0ZXJEYXRhICYmIHJvdXRlckZpbHRlclNWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0aWNGaWx0ZXJEYXRhID0gcm91dGVyRmlsdGVyU1ZhbHVlID8gcm91dGVyRmlsdGVyU1ZhbHVlIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByb3V0ZXJGaWx0ZXJEVmFsdWUgPSBwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1JPVVRFUl9EX0ZJTFRFUjtcbiAgICAgICAgICAgICAgICBpZiAoIWR5bmFtaWNGaWx0ZXJEYXRhICYmIHJvdXRlckZpbHRlckRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljRmlsdGVyRGF0YSA9IHJvdXRlckZpbHRlckRWYWx1ZSA/IHJvdXRlckZpbHRlckRWYWx1ZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRpY0ZpbHRlckRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRpY0ZpbHRlckRhdGEubnVtSGFzaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JmbF9zID0gbmV3IEJsb29tRmlsdGVyKHN0YXRpY0ZpbHRlckRhdGEubnVtSXRlbXMsIHN0YXRpY0ZpbHRlckRhdGEuZXJyb3JSYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmZsX3MuaW1wb3J0KHN0YXRpY0ZpbHRlckRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZHluYW1pY0ZpbHRlckRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGR5bmFtaWNGaWx0ZXJEYXRhLm51bUhhc2hlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9iZmxfZCA9IG5ldyBCbG9vbUZpbHRlcihkeW5hbWljRmlsdGVyRGF0YS5udW1JdGVtcywgZHluYW1pY0ZpbHRlckRhdGEuZXJyb3JSYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmZsX2QuaW1wb3J0KGR5bmFtaWNGaWx0ZXJEYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbWF0Y2hlc0JmbFN0YXRpYyA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IG1hdGNoZXNCZmxEeW5hbWljID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBwYXRoc1RvQ2hlY2sgPSBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBhc1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBhczogcmVzb2x2ZWRBc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHsgYXM6IGN1ckFzLCBhbGxvd01hdGNoQ3VycmVudCB9IG9mIHBhdGhzVG9DaGVjayl7XG4gICAgICAgICAgICAgICAgaWYgKGN1ckFzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFzTm9TbGFzaCA9ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShuZXcgVVJMKGN1ckFzLCAnaHR0cDovL24nKS5wYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFzTm9TbGFzaExvY2FsZSA9ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKCgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkoYXNOb1NsYXNoLCBsb2NhbGUgfHwgdGhpcy5sb2NhbGUpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsbG93TWF0Y2hDdXJyZW50IHx8IGFzTm9TbGFzaCAhPT0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKG5ldyBVUkwodGhpcy5hc1BhdGgsICdodHRwOi8vbicpLnBhdGhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzX19iZmxfcywgX3RoaXNfX2JmbF9zMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXNCZmxTdGF0aWMgPSBtYXRjaGVzQmZsU3RhdGljIHx8ICEhKChfdGhpc19fYmZsX3MgPSB0aGlzLl9iZmxfcykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzX19iZmxfcy5jb250YWlucyhhc05vU2xhc2gpKSB8fCAhISgoX3RoaXNfX2JmbF9zMSA9IHRoaXMuX2JmbF9zKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXNfX2JmbF9zMS5jb250YWlucyhhc05vU2xhc2hMb2NhbGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgbm9ybWFsaXplZEFTIG9mIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc05vU2xhc2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNOb1NsYXNoTG9jYWxlXG4gICAgICAgICAgICAgICAgICAgICAgICBdKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBhbnkgc3ViLXBhdGggb2YgYXMgbWF0Y2hlcyBhIGR5bmFtaWMgZmlsdGVyIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCBzaG91bGQgYmUgaGFyZCBuYXZpZ2F0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJBc1BhcnRzID0gbm9ybWFsaXplZEFTLnNwbGl0KCcvJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgIW1hdGNoZXNCZmxEeW5hbWljICYmIGkgPCBjdXJBc1BhcnRzLmxlbmd0aCArIDE7IGkrKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfdGhpc19fYmZsX2Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQYXJ0ID0gY3VyQXNQYXJ0cy5zbGljZSgwLCBpKS5qb2luKCcvJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UGFydCAmJiAoKF90aGlzX19iZmxfZCA9IHRoaXMuX2JmbF9kKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXNfX2JmbF9kLmNvbnRhaW5zKGN1cnJlbnRQYXJ0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXNCZmxEeW5hbWljID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGNsaWVudCByb3V0ZXIgZmlsdGVyIGlzIG1hdGNoZWQgdGhlbiB3ZSB0cmlnZ2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhIGhhcmQgbmF2aWdhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXNCZmxTdGF0aWMgfHwgbWF0Y2hlc0JmbER5bmFtaWMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2tpcE5hdmlnYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkoKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKShhcywgbG9jYWxlIHx8IHRoaXMubG9jYWxlLCB0aGlzLmRlZmF1bHRMb2NhbGUpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhc3luYyBjaGFuZ2UobWV0aG9kLCB1cmwsIGFzLCBvcHRpb25zLCBmb3JjZWRTY3JvbGwpIHtcbiAgICAgICAgdmFyIF90aGlzX2NvbXBvbmVudHNfcGF0aG5hbWU7XG4gICAgICAgIGlmICghKDAsIF9pc2xvY2FsdXJsLmlzTG9jYWxVUkwpKHVybCkpIHtcbiAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXQVJOSU5HOiBgX2hgIGlzIGFuIGludGVybmFsIG9wdGlvbiBmb3IgaGFuZGluZyBOZXh0LmpzIGNsaWVudC1zaWRlXG4gICAgICAgIC8vIGh5ZHJhdGlvbi4gWW91ciBhcHAgc2hvdWxkIF9uZXZlcl8gdXNlIHRoaXMgcHJvcGVydHkuIEl0IG1heSBjaGFuZ2UgYXRcbiAgICAgICAgLy8gYW55IHRpbWUgd2l0aG91dCBub3RpY2UuXG4gICAgICAgIGNvbnN0IGlzUXVlcnlVcGRhdGluZyA9IG9wdGlvbnMuX2ggPT09IDE7XG4gICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nICYmICFvcHRpb25zLnNoYWxsb3cpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2JmbChhcywgdW5kZWZpbmVkLCBvcHRpb25zLmxvY2FsZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNob3VsZFJlc29sdmVIcmVmID0gaXNRdWVyeVVwZGF0aW5nIHx8IG9wdGlvbnMuX3Nob3VsZFJlc29sdmVIcmVmIHx8ICgwLCBfcGFyc2VwYXRoLnBhcnNlUGF0aCkodXJsKS5wYXRobmFtZSA9PT0gKDAsIF9wYXJzZXBhdGgucGFyc2VQYXRoKShhcykucGF0aG5hbWU7XG4gICAgICAgIGNvbnN0IG5leHRTdGF0ZSA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuc3RhdGVcbiAgICAgICAgfTtcbiAgICAgICAgLy8gZm9yIHN0YXRpYyBwYWdlcyB3aXRoIHF1ZXJ5IHBhcmFtcyBpbiB0aGUgVVJMIHdlIGRlbGF5XG4gICAgICAgIC8vIG1hcmtpbmcgdGhlIHJvdXRlciByZWFkeSB1bnRpbCBhZnRlciB0aGUgcXVlcnkgaXMgdXBkYXRlZFxuICAgICAgICAvLyBvciBhIG5hdmlnYXRpb24gaGFzIG9jY3VycmVkXG4gICAgICAgIGNvbnN0IHJlYWR5U3RhdGVDaGFuZ2UgPSB0aGlzLmlzUmVhZHkgIT09IHRydWU7XG4gICAgICAgIHRoaXMuaXNSZWFkeSA9IHRydWU7XG4gICAgICAgIGNvbnN0IGlzU3NyID0gdGhpcy5pc1NzcjtcbiAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuaXNTc3IgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBhIHJvdXRlIHRyYW5zaXRpb24gaXMgYWxyZWFkeSBpbiBwcm9ncmVzcyBiZWZvcmVcbiAgICAgICAgLy8gdGhlIHF1ZXJ5IHVwZGF0aW5nIGlzIHRyaWdnZXJlZCBpZ25vcmUgcXVlcnkgdXBkYXRpbmdcbiAgICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZyAmJiB0aGlzLmNsYykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXZMb2NhbGUgPSBuZXh0U3RhdGUubG9jYWxlO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgbmV4dFN0YXRlLmxvY2FsZSA9IG9wdGlvbnMubG9jYWxlID09PSBmYWxzZSA/IHRoaXMuZGVmYXVsdExvY2FsZSA6IG9wdGlvbnMubG9jYWxlIHx8IG5leHRTdGF0ZS5sb2NhbGU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMubG9jYWxlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMubG9jYWxlID0gbmV4dFN0YXRlLmxvY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFzID0gKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKCgwLCBfaGFzYmFzZXBhdGguaGFzQmFzZVBhdGgpKGFzKSA/ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKGFzKSA6IGFzKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsZVBhdGhSZXN1bHQgPSAoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkocGFyc2VkQXMucGF0aG5hbWUsIHRoaXMubG9jYWxlcyk7XG4gICAgICAgICAgICBpZiAobG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZSkge1xuICAgICAgICAgICAgICAgIG5leHRTdGF0ZS5sb2NhbGUgPSBsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlO1xuICAgICAgICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkocGFyc2VkQXMucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgIGFzID0gKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHBhcnNlZEFzKTtcbiAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkoKDAsIF9oYXNiYXNlcGF0aC5oYXNCYXNlUGF0aCkodXJsKSA/ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKHVybCkgOiB1cmwsIHRoaXMubG9jYWxlcykucGF0aG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGRpZE5hdmlnYXRlID0gZmFsc2U7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHdyYXAgdGhpcyBpbiB0aGUgZW52IGNoZWNrIGFnYWluIHNpbmNlIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgICAgICAgIC8vIG1vdmVzIHRoaXMgb24gaXRzIG93biBkdWUgdG8gdGhlIHJldHVyblxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXNfbG9jYWxlcztcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgbG9jYWxlIGlzbid0IGNvbmZpZ3VyZWQgaGFyZCBuYXZpZ2F0ZSB0byBzaG93IDQwNCBwYWdlXG4gICAgICAgICAgICAgICAgaWYgKCEoKF90aGlzX2xvY2FsZXMgPSB0aGlzLmxvY2FsZXMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpc19sb2NhbGVzLmluY2x1ZGVzKG5leHRTdGF0ZS5sb2NhbGUpKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSA9ICgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkocGFyc2VkQXMucGF0aG5hbWUsIG5leHRTdGF0ZS5sb2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShwYXJzZWRBcyksXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd2FzIHByZXZpb3VzbHkgYSByZXR1cm4gYnV0IHdhcyByZW1vdmVkIGluIGZhdm9yXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIGJldHRlciBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2l0aCByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgICAgICAgICAgIGRpZE5hdmlnYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZXRlY3RlZERvbWFpbiA9ICgwLCBfZGV0ZWN0ZG9tYWlubG9jYWxlLmRldGVjdERvbWFpbkxvY2FsZSkodGhpcy5kb21haW5Mb2NhbGVzLCB1bmRlZmluZWQsIG5leHRTdGF0ZS5sb2NhbGUpO1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byB3cmFwIHRoaXMgaW4gdGhlIGVudiBjaGVjayBhZ2FpbiBzaW5jZSByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgICAvLyBtb3ZlcyB0aGlzIG9uIGl0cyBvd24gZHVlIHRvIHRoZSByZXR1cm5cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgYXJlIG5hdmlnYXRpbmcgdG8gYSBkb21haW4gbG9jYWxlIGVuc3VyZSB3ZSByZWRpcmVjdCB0byB0aGVcbiAgICAgICAgICAgICAgICAvLyBjb3JyZWN0IGRvbWFpblxuICAgICAgICAgICAgICAgIGlmICghZGlkTmF2aWdhdGUgJiYgZGV0ZWN0ZWREb21haW4gJiYgdGhpcy5pc0xvY2FsZURvbWFpbiAmJiBzZWxmLmxvY2F0aW9uLmhvc3RuYW1lICE9PSBkZXRlY3RlZERvbWFpbi5kb21haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXNOb0Jhc2VQYXRoID0gKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkoYXMpO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IFwiaHR0cFwiICsgKGRldGVjdGVkRG9tYWluLmh0dHAgPyAnJyA6ICdzJykgKyBcIjovL1wiICsgZGV0ZWN0ZWREb21haW4uZG9tYWluICsgKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkoXCJcIiArIChuZXh0U3RhdGUubG9jYWxlID09PSBkZXRlY3RlZERvbWFpbi5kZWZhdWx0TG9jYWxlID8gJycgOiBcIi9cIiArIG5leHRTdGF0ZS5sb2NhbGUpICsgKGFzTm9CYXNlUGF0aCA9PT0gJy8nID8gJycgOiBhc05vQmFzZVBhdGgpIHx8ICcvJyksXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd2FzIHByZXZpb3VzbHkgYSByZXR1cm4gYnV0IHdhcyByZW1vdmVkIGluIGZhdm9yXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIGJldHRlciBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2l0aCByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgICAgICAgICAgIGRpZE5hdmlnYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlkTmF2aWdhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCk9Pnt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBtYXJraW5nIHJvdXRlIGNoYW5nZXMgYXMgYSBuYXZpZ2F0aW9uIHN0YXJ0IGVudHJ5XG4gICAgICAgIGlmIChfdXRpbHMuU1QpIHtcbiAgICAgICAgICAgIHBlcmZvcm1hbmNlLm1hcmsoJ3JvdXRlQ2hhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzaGFsbG93ID0gZmFsc2UsIHNjcm9sbCA9IHRydWUgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHJvdXRlUHJvcHMgPSB7XG4gICAgICAgICAgICBzaGFsbG93XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLl9pbkZsaWdodFJvdXRlICYmIHRoaXMuY2xjKSB7XG4gICAgICAgICAgICBpZiAoIWlzU3NyKSB7XG4gICAgICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUVycm9yJywgYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpLCB0aGlzLl9pbkZsaWdodFJvdXRlLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2xjKCk7XG4gICAgICAgICAgICB0aGlzLmNsYyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYXMgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKCgwLCBfaGFzYmFzZXBhdGguaGFzQmFzZVBhdGgpKGFzKSA/ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKGFzKSA6IGFzLCBvcHRpb25zLmxvY2FsZSwgdGhpcy5kZWZhdWx0TG9jYWxlKSk7XG4gICAgICAgIGNvbnN0IGNsZWFuZWRBcyA9ICgwLCBfcmVtb3ZlbG9jYWxlLnJlbW92ZUxvY2FsZSkoKDAsIF9oYXNiYXNlcGF0aC5oYXNCYXNlUGF0aCkoYXMpID8gKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkoYXMpIDogYXMsIG5leHRTdGF0ZS5sb2NhbGUpO1xuICAgICAgICB0aGlzLl9pbkZsaWdodFJvdXRlID0gYXM7XG4gICAgICAgIGNvbnN0IGxvY2FsZUNoYW5nZSA9IHByZXZMb2NhbGUgIT09IG5leHRTdGF0ZS5sb2NhbGU7XG4gICAgICAgIC8vIElmIHRoZSB1cmwgY2hhbmdlIGlzIG9ubHkgcmVsYXRlZCB0byBhIGhhc2ggY2hhbmdlXG4gICAgICAgIC8vIFdlIHNob3VsZCBub3QgcHJvY2VlZC4gV2Ugc2hvdWxkIG9ubHkgY2hhbmdlIHRoZSBzdGF0ZS5cbiAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcgJiYgdGhpcy5vbmx5QUhhc2hDaGFuZ2UoY2xlYW5lZEFzKSAmJiAhbG9jYWxlQ2hhbmdlKSB7XG4gICAgICAgICAgICBuZXh0U3RhdGUuYXNQYXRoID0gY2xlYW5lZEFzO1xuICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdoYXNoQ2hhbmdlU3RhcnQnLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAvLyBUT0RPOiBkbyB3ZSBuZWVkIHRoZSByZXNvbHZlZCBocmVmIHdoZW4gb25seSBhIGhhc2ggY2hhbmdlP1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShtZXRob2QsIHVybCwgYXMsIHtcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAgIHNjcm9sbDogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHNjcm9sbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9IYXNoKGNsZWFuZWRBcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0KG5leHRTdGF0ZSwgdGhpcy5jb21wb25lbnRzW25leHRTdGF0ZS5yb3V0ZV0sIG51bGwpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBfaXNlcnJvci5kZWZhdWx0KShlcnIpICYmIGVyci5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUVycm9yJywgZXJyLCBjbGVhbmVkQXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ2hhc2hDaGFuZ2VDb21wbGV0ZScsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJzZWQgPSAoMCwgX3BhcnNlcmVsYXRpdmV1cmwucGFyc2VSZWxhdGl2ZVVybCkodXJsKTtcbiAgICAgICAgbGV0IHsgcGF0aG5hbWUsIHF1ZXJ5IH0gPSBwYXJzZWQ7XG4gICAgICAgIC8vIFRoZSBidWlsZCBtYW5pZmVzdCBuZWVkcyB0byBiZSBsb2FkZWQgYmVmb3JlIGF1dG8tc3RhdGljIGR5bmFtaWMgcGFnZXNcbiAgICAgICAgLy8gZ2V0IHRoZWlyIHF1ZXJ5IHBhcmFtZXRlcnMgdG8gYWxsb3cgZW5zdXJpbmcgdGhleSBjYW4gYmUgcGFyc2VkIHByb3Blcmx5XG4gICAgICAgIC8vIHdoZW4gcmV3cml0dGVuIHRvXG4gICAgICAgIGxldCBwYWdlcywgcmV3cml0ZXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICA7XG4gICAgICAgICAgICBbcGFnZXMsIHsgX19yZXdyaXRlczogcmV3cml0ZXMgfV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgdGhpcy5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KCksXG4gICAgICAgICAgICAgICAgKDAsIF9yb3V0ZWxvYWRlci5nZXRDbGllbnRCdWlsZE1hbmlmZXN0KSgpLFxuICAgICAgICAgICAgICAgIHRoaXMucGFnZUxvYWRlci5nZXRNaWRkbGV3YXJlKClcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGZhaWwgdG8gcmVzb2x2ZSB0aGUgcGFnZSBsaXN0IG9yIGNsaWVudC1idWlsZCBtYW5pZmVzdCwgd2UgbXVzdFxuICAgICAgICAgICAgLy8gZG8gYSBzZXJ2ZXItc2lkZSB0cmFuc2l0aW9uOlxuICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgIHVybDogYXMsXG4gICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBhc2tlZCB0byBjaGFuZ2UgdGhlIGN1cnJlbnQgVVJMIHdlIHNob3VsZCByZWxvYWQgdGhlIGN1cnJlbnQgcGFnZVxuICAgICAgICAvLyAobm90IGxvY2F0aW9uLnJlbG9hZCgpIGJ1dCByZWxvYWQgZ2V0SW5pdGlhbFByb3BzIGFuZCBvdGhlciBOZXh0LmpzIHN0dWZmcylcbiAgICAgICAgLy8gV2UgYWxzbyBuZWVkIHRvIHNldCB0aGUgbWV0aG9kID0gcmVwbGFjZVN0YXRlIGFsd2F5c1xuICAgICAgICAvLyBhcyB0aGlzIHNob3VsZCBub3QgZ28gaW50byB0aGUgaGlzdG9yeSAoVGhhdCdzIGhvdyBicm93c2VycyB3b3JrKVxuICAgICAgICAvLyBXZSBzaG91bGQgY29tcGFyZSB0aGUgbmV3IGFzUGF0aCB0byB0aGUgY3VycmVudCBhc1BhdGgsIG5vdCB0aGUgdXJsXG4gICAgICAgIGlmICghdGhpcy51cmxJc05ldyhjbGVhbmVkQXMpICYmICFsb2NhbGVDaGFuZ2UpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdyZXBsYWNlU3RhdGUnO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gcmVzb2x2ZSB0aGUgYXMgdmFsdWUgdXNpbmcgcmV3cml0ZXMgZm9yIGR5bmFtaWMgU1NHXG4gICAgICAgIC8vIHBhZ2VzIHRvIGFsbG93IGJ1aWxkaW5nIHRoZSBkYXRhIFVSTCBjb3JyZWN0bHlcbiAgICAgICAgbGV0IHJlc29sdmVkQXMgPSBhcztcbiAgICAgICAgLy8gdXJsIGFuZCBhcyBzaG91bGQgYWx3YXlzIGJlIHByZWZpeGVkIHdpdGggYmFzZVBhdGggYnkgdGhpc1xuICAgICAgICAvLyBwb2ludCBieSBlaXRoZXIgbmV4dC9saW5rIG9yIHJvdXRlci5wdXNoL3JlcGxhY2Ugc28gc3RyaXAgdGhlXG4gICAgICAgIC8vIGJhc2VQYXRoIGZyb20gdGhlIHBhdGhuYW1lIHRvIG1hdGNoIHRoZSBwYWdlcyBkaXIgMS10by0xXG4gICAgICAgIHBhdGhuYW1lID0gcGF0aG5hbWUgPyAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkoKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkocGF0aG5hbWUpKSA6IHBhdGhuYW1lO1xuICAgICAgICBsZXQgcm91dGUgPSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkocGF0aG5hbWUpO1xuICAgICAgICBjb25zdCBwYXJzZWRBc1BhdGhuYW1lID0gYXMuc3RhcnRzV2l0aCgnLycpICYmICgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKShhcykucGF0aG5hbWU7XG4gICAgICAgIC8vIGlmIHdlIGRldGVjdGVkIHRoZSBwYXRoIGFzIGFwcCByb3V0ZSBkdXJpbmcgcHJlZmV0Y2hpbmdcbiAgICAgICAgLy8gdHJpZ2dlciBoYXJkIG5hdmlnYXRpb25cbiAgICAgICAgaWYgKChfdGhpc19jb21wb25lbnRzX3BhdGhuYW1lID0gdGhpcy5jb21wb25lbnRzW3BhdGhuYW1lXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzX2NvbXBvbmVudHNfcGF0aG5hbWUuX19hcHBSb3V0ZXIpIHtcbiAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICB1cmw6IGFzLFxuICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCk9Pnt9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc01pZGRsZXdhcmVSZXdyaXRlID0gISEocGFyc2VkQXNQYXRobmFtZSAmJiByb3V0ZSAhPT0gcGFyc2VkQXNQYXRobmFtZSAmJiAoISgwLCBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlKShyb3V0ZSkgfHwgISgwLCBfcm91dGVtYXRjaGVyLmdldFJvdXRlTWF0Y2hlcikoKDAsIF9yb3V0ZXJlZ2V4LmdldFJvdXRlUmVnZXgpKHJvdXRlKSkocGFyc2VkQXNQYXRobmFtZSkpKTtcbiAgICAgICAgLy8gd2UgZG9uJ3QgYXR0ZW1wdCByZXNvbHZlIGFzUGF0aCB3aGVuIHdlIG5lZWQgdG8gZXhlY3V0ZVxuICAgICAgICAvLyBtaWRkbGV3YXJlIGFzIHRoZSByZXNvbHZpbmcgd2lsbCBvY2N1ciBzZXJ2ZXItc2lkZVxuICAgICAgICBjb25zdCBpc01pZGRsZXdhcmVNYXRjaCA9ICFvcHRpb25zLnNoYWxsb3cgJiYgYXdhaXQgbWF0Y2hlc01pZGRsZXdhcmUoe1xuICAgICAgICAgICAgYXNQYXRoOiBhcyxcbiAgICAgICAgICAgIGxvY2FsZTogbmV4dFN0YXRlLmxvY2FsZSxcbiAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZyAmJiBpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgc2hvdWxkUmVzb2x2ZUhyZWYgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkUmVzb2x2ZUhyZWYgJiYgcGF0aG5hbWUgIT09ICcvX2Vycm9yJykge1xuICAgICAgICAgICAgO1xuICAgICAgICAgICAgb3B0aW9ucy5fc2hvdWxkUmVzb2x2ZUhyZWYgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMgJiYgYXMuc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV3cml0ZXNSZXN1bHQgPSAoMCwgX3Jlc29sdmVyZXdyaXRlcy5kZWZhdWx0KSgoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKGNsZWFuZWRBcywgbmV4dFN0YXRlLmxvY2FsZSksIHRydWUpLCBwYWdlcywgcmV3cml0ZXMsIHF1ZXJ5LCAocCk9PnJlc29sdmVEeW5hbWljUm91dGUocCwgcGFnZXMpLCB0aGlzLmxvY2FsZXMpO1xuICAgICAgICAgICAgICAgIGlmIChyZXdyaXRlc1Jlc3VsdC5leHRlcm5hbERlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBhcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRBcyA9IHJld3JpdGVzUmVzdWx0LmFzUGF0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJld3JpdGVzUmVzdWx0Lm1hdGNoZWRQYWdlICYmIHJld3JpdGVzUmVzdWx0LnJlc29sdmVkSHJlZikge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGRpcmVjdGx5IG1hdGNoZXMgYSBwYWdlIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBocmVmIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsbG93IHRoZSBjb3JyZWN0IHBhZ2UgY2h1bmsgdG8gYmUgbG9hZGVkXG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKShwYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShwYXJzZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSByZXNvbHZlRHluYW1pY1JvdXRlKHBhdGhuYW1lLCBwYWdlcyk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZC5wYXRobmFtZSAhPT0gcGF0aG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUgPSBwYXJzZWQucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoMCwgX2lzbG9jYWx1cmwuaXNMb2NhbFVSTCkoYXMpKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXcgRXJyb3IoJ0ludmFsaWQgaHJlZjogXCInICsgdXJsICsgJ1wiIGFuZCBhczogXCInICsgYXMgKyAnXCIsIHJlY2VpdmVkIHJlbGF0aXZlIGhyZWYgYW5kIGV4dGVybmFsIGFzJyArIFwiXFxuU2VlIG1vcmUgaW5mbzogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvaW52YWxpZC1yZWxhdGl2ZS11cmwtZXh0ZXJuYWwtYXNcIiksIFwiX19ORVhUX0VSUk9SX0NPREVcIiwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCJFMzgwXCIsXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICB1cmw6IGFzLFxuICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZWRBcyA9ICgwLCBfcmVtb3ZlbG9jYWxlLnJlbW92ZUxvY2FsZSkoKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkocmVzb2x2ZWRBcyksIG5leHRTdGF0ZS5sb2NhbGUpO1xuICAgICAgICByb3V0ZSA9ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShwYXRobmFtZSk7XG4gICAgICAgIGxldCByb3V0ZU1hdGNoID0gZmFsc2U7XG4gICAgICAgIGlmICgoMCwgX2lzZHluYW1pYy5pc0R5bmFtaWNSb3V0ZSkocm91dGUpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRBcyA9ICgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKShyZXNvbHZlZEFzKTtcbiAgICAgICAgICAgIGNvbnN0IGFzUGF0aG5hbWUgPSBwYXJzZWRBcy5wYXRobmFtZTtcbiAgICAgICAgICAgIGNvbnN0IHJvdXRlUmVnZXggPSAoMCwgX3JvdXRlcmVnZXguZ2V0Um91dGVSZWdleCkocm91dGUpO1xuICAgICAgICAgICAgcm91dGVNYXRjaCA9ICgwLCBfcm91dGVtYXRjaGVyLmdldFJvdXRlTWF0Y2hlcikocm91dGVSZWdleCkoYXNQYXRobmFtZSk7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRJbnRlcnBvbGF0ZSA9IHJvdXRlID09PSBhc1BhdGhuYW1lO1xuICAgICAgICAgICAgY29uc3QgaW50ZXJwb2xhdGVkQXMgPSBzaG91bGRJbnRlcnBvbGF0ZSA/ICgwLCBfaW50ZXJwb2xhdGVhcy5pbnRlcnBvbGF0ZUFzKShyb3V0ZSwgYXNQYXRobmFtZSwgcXVlcnkpIDoge307XG4gICAgICAgICAgICBpZiAoIXJvdXRlTWF0Y2ggfHwgc2hvdWxkSW50ZXJwb2xhdGUgJiYgIWludGVycG9sYXRlZEFzLnJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pc3NpbmdQYXJhbXMgPSBPYmplY3Qua2V5cyhyb3V0ZVJlZ2V4Lmdyb3VwcykuZmlsdGVyKChwYXJhbSk9PiFxdWVyeVtwYXJhbV0gJiYgIXJvdXRlUmVnZXguZ3JvdXBzW3BhcmFtXS5vcHRpb25hbCk7XG4gICAgICAgICAgICAgICAgaWYgKG1pc3NpbmdQYXJhbXMubGVuZ3RoID4gMCAmJiAhaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlwiICsgKHNob3VsZEludGVycG9sYXRlID8gXCJJbnRlcnBvbGF0aW5nIGhyZWZcIiA6IFwiTWlzbWF0Y2hpbmcgYGFzYCBhbmQgYGhyZWZgXCIpICsgXCIgZmFpbGVkIHRvIG1hbnVhbGx5IHByb3ZpZGUgXCIgKyAoXCJ0aGUgcGFyYW1zOiBcIiArIG1pc3NpbmdQYXJhbXMuam9pbignLCAnKSArIFwiIGluIHRoZSBgaHJlZmAncyBgcXVlcnlgXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3IEVycm9yKChzaG91bGRJbnRlcnBvbGF0ZSA/IFwiVGhlIHByb3ZpZGVkIGBocmVmYCAoXCIgKyB1cmwgKyBcIikgdmFsdWUgaXMgbWlzc2luZyBxdWVyeSB2YWx1ZXMgKFwiICsgbWlzc2luZ1BhcmFtcy5qb2luKCcsICcpICsgXCIpIHRvIGJlIGludGVycG9sYXRlZCBwcm9wZXJseS4gXCIgOiBcIlRoZSBwcm92aWRlZCBgYXNgIHZhbHVlIChcIiArIGFzUGF0aG5hbWUgKyBcIikgaXMgaW5jb21wYXRpYmxlIHdpdGggdGhlIGBocmVmYCB2YWx1ZSAoXCIgKyByb3V0ZSArIFwiKS4gXCIpICsgKFwiUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9cIiArIChzaG91bGRJbnRlcnBvbGF0ZSA/ICdocmVmLWludGVycG9sYXRpb24tZmFpbGVkJyA6ICdpbmNvbXBhdGlibGUtaHJlZi1hcycpKSksIFwiX19ORVhUX0VSUk9SX0NPREVcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFwiRTM0NFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzaG91bGRJbnRlcnBvbGF0ZSkge1xuICAgICAgICAgICAgICAgIGFzID0gKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKE9iamVjdC5hc3NpZ24oe30sIHBhcnNlZEFzLCB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lOiBpbnRlcnBvbGF0ZWRBcy5yZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiAoMCwgX29taXQub21pdCkocXVlcnksIGludGVycG9sYXRlZEFzLnBhcmFtcylcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE1lcmdlIHBhcmFtcyBpbnRvIGBxdWVyeWAsIG92ZXJ3cml0aW5nIGFueSBzcGVjaWZpZWQgaW4gc2VhcmNoXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihxdWVyeSwgcm91dGVNYXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VTdGFydCcsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0Vycm9yUm91dGUgPSB0aGlzLnBhdGhuYW1lID09PSAnLzQwNCcgfHwgdGhpcy5wYXRobmFtZSA9PT0gJy9fZXJyb3InO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHNfcGFnZVByb3BzLCBfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzLCBfcm91dGVJbmZvX3Byb3BzO1xuICAgICAgICAgICAgbGV0IHJvdXRlSW5mbyA9IGF3YWl0IHRoaXMuZ2V0Um91dGVJbmZvKHtcbiAgICAgICAgICAgICAgICByb3V0ZSxcbiAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICBhcyxcbiAgICAgICAgICAgICAgICByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgIHJvdXRlUHJvcHMsXG4gICAgICAgICAgICAgICAgbG9jYWxlOiBuZXh0U3RhdGUubG9jYWxlLFxuICAgICAgICAgICAgICAgIGlzUHJldmlldzogbmV4dFN0YXRlLmlzUHJldmlldyxcbiAgICAgICAgICAgICAgICBoYXNNaWRkbGV3YXJlOiBpc01pZGRsZXdhcmVNYXRjaCxcbiAgICAgICAgICAgICAgICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGU6IG9wdGlvbnMudW5zdGFibGVfc2tpcENsaWVudENhY2hlLFxuICAgICAgICAgICAgICAgIGlzUXVlcnlVcGRhdGluZzogaXNRdWVyeVVwZGF0aW5nICYmICF0aGlzLmlzRmFsbGJhY2ssXG4gICAgICAgICAgICAgICAgaXNNaWRkbGV3YXJlUmV3cml0ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZyAmJiAhb3B0aW9ucy5zaGFsbG93KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fYmZsKGFzLCAncmVzb2x2ZWRBcycgaW4gcm91dGVJbmZvID8gcm91dGVJbmZvLnJlc29sdmVkQXMgOiB1bmRlZmluZWQsIG5leHRTdGF0ZS5sb2NhbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdyb3V0ZScgaW4gcm91dGVJbmZvICYmIGlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcGF0aG5hbWUgPSByb3V0ZUluZm8ucm91dGUgfHwgcm91dGU7XG4gICAgICAgICAgICAgICAgcm91dGUgPSBwYXRobmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoIXJvdXRlUHJvcHMuc2hhbGxvdykge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IE9iamVjdC5hc3NpZ24oe30sIHJvdXRlSW5mby5xdWVyeSB8fCB7fSwgcXVlcnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjbGVhbmVkUGFyc2VkUGF0aG5hbWUgPSAoMCwgX2hhc2Jhc2VwYXRoLmhhc0Jhc2VQYXRoKShwYXJzZWQucGF0aG5hbWUpID8gKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkocGFyc2VkLnBhdGhuYW1lKSA6IHBhcnNlZC5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICBpZiAocm91dGVNYXRjaCAmJiBwYXRobmFtZSAhPT0gY2xlYW5lZFBhcnNlZFBhdGhuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHJvdXRlTWF0Y2gpLmZvckVhY2goKGtleSk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb3V0ZU1hdGNoICYmIHF1ZXJ5W2tleV0gPT09IHJvdXRlTWF0Y2hba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBxdWVyeVtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlKShwYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlZml4ZWRBcyA9ICFyb3V0ZVByb3BzLnNoYWxsb3cgJiYgcm91dGVJbmZvLnJlc29sdmVkQXMgPyByb3V0ZUluZm8ucmVzb2x2ZWRBcyA6ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKCgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkobmV3IFVSTChhcywgbG9jYXRpb24uaHJlZikucGF0aG5hbWUsIG5leHRTdGF0ZS5sb2NhbGUpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJld3JpdGVBcyA9IHByZWZpeGVkQXM7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgX2hhc2Jhc2VwYXRoLmhhc0Jhc2VQYXRoKShyZXdyaXRlQXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXdyaXRlQXMgPSAoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShyZXdyaXRlQXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhbGVSZXN1bHQgPSAoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkocmV3cml0ZUFzLCB0aGlzLmxvY2FsZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFN0YXRlLmxvY2FsZSA9IGxvY2FsZVJlc3VsdC5kZXRlY3RlZExvY2FsZSB8fCBuZXh0U3RhdGUubG9jYWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV3cml0ZUFzID0gbG9jYWxlUmVzdWx0LnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvdXRlUmVnZXggPSAoMCwgX3JvdXRlcmVnZXguZ2V0Um91dGVSZWdleCkocGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJSb3V0ZU1hdGNoID0gKDAsIF9yb3V0ZW1hdGNoZXIuZ2V0Um91dGVNYXRjaGVyKShyb3V0ZVJlZ2V4KShuZXcgVVJMKHJld3JpdGVBcywgbG9jYXRpb24uaHJlZikucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyUm91dGVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihxdWVyeSwgY3VyUm91dGVNYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgcm91dGVJbmZvIGJyaW5ncyBhIHJlZGlyZWN0IHdlIHNpbXBseSBhcHBseSBpdC5cbiAgICAgICAgICAgIGlmICgndHlwZScgaW4gcm91dGVJbmZvKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvdXRlSW5mby50eXBlID09PSAncmVkaXJlY3QtaW50ZXJuYWwnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5nZShtZXRob2QsIHJvdXRlSW5mby5uZXdVcmwsIHJvdXRlSW5mby5uZXdBcywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiByb3V0ZUluZm8uZGVzdGluYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IHJvdXRlSW5mby5Db21wb25lbnQ7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50ICYmIGNvbXBvbmVudC51bnN0YWJsZV9zY3JpcHRMb2FkZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY3JpcHRzID0gW10uY29uY2F0KGNvbXBvbmVudC51bnN0YWJsZV9zY3JpcHRMb2FkZXIoKSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0cy5mb3JFYWNoKChzY3JpcHQpPT57XG4gICAgICAgICAgICAgICAgICAgICgwLCBfc2NyaXB0LmhhbmRsZUNsaWVudFNjcmlwdExvYWQpKHNjcmlwdC5wcm9wcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBoYW5kbGUgcmVkaXJlY3Qgb24gY2xpZW50LXRyYW5zaXRpb25cbiAgICAgICAgICAgIGlmICgocm91dGVJbmZvLl9fTl9TU0cgfHwgcm91dGVJbmZvLl9fTl9TU1ApICYmIHJvdXRlSW5mby5wcm9wcykge1xuICAgICAgICAgICAgICAgIGlmIChyb3V0ZUluZm8ucHJvcHMucGFnZVByb3BzICYmIHJvdXRlSW5mby5wcm9wcy5wYWdlUHJvcHMuX19OX1JFRElSRUNUKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgZGVzdGluYXRpb24gZnJvbSByZWRpcmVjdCB3aXRob3V0IGFkZGluZyBsb2NhbGVcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5sb2NhbGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVzdGluYXRpb24gPSByb3V0ZUluZm8ucHJvcHMucGFnZVByb3BzLl9fTl9SRURJUkVDVDtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgZGVzdGluYXRpb24gaXMgaW50ZXJuYWwgKHJlc29sdmVzIHRvIGEgcGFnZSkgYW5kIGF0dGVtcHRcbiAgICAgICAgICAgICAgICAgICAgLy8gY2xpZW50LW5hdmlnYXRpb24gaWYgaXQgaXMgZmFsbGluZyBiYWNrIHRvIGhhcmQgbmF2aWdhdGlvbiBpZlxuICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIG5vdFxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVzdGluYXRpb24uc3RhcnRzV2l0aCgnLycpICYmIHJvdXRlSW5mby5wcm9wcy5wYWdlUHJvcHMuX19OX1JFRElSRUNUX0JBU0VfUEFUSCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZEhyZWYgPSAoMCwgX3BhcnNlcmVsYXRpdmV1cmwucGFyc2VSZWxhdGl2ZVVybCkoZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkSHJlZi5wYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUocGFyc2VkSHJlZi5wYXRobmFtZSwgcGFnZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB1cmw6IG5ld1VybCwgYXM6IG5ld0FzIH0gPSBwcmVwYXJlVXJsQXModGhpcywgZGVzdGluYXRpb24sIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5nZShtZXRob2QsIG5ld1VybCwgbmV3QXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogZGVzdGluYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0U3RhdGUuaXNQcmV2aWV3ID0gISFyb3V0ZUluZm8ucHJvcHMuX19OX1BSRVZJRVc7XG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIFNTRyBkYXRhIDQwNFxuICAgICAgICAgICAgICAgIGlmIChyb3V0ZUluZm8ucHJvcHMubm90Rm91bmQgPT09IFNTR19EQVRBX05PVF9GT1VORCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbm90Rm91bmRSb3V0ZTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQoJy80MDQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdEZvdW5kUm91dGUgPSAnLzQwNCc7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdEZvdW5kUm91dGUgPSAnL19lcnJvcic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvID0gYXdhaXQgdGhpcy5nZXRSb3V0ZUluZm8oe1xuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGU6IG5vdEZvdW5kUm91dGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogbm90Rm91bmRSb3V0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXMsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVQcm9wczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYWxsb3c6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiBuZXh0U3RhdGUubG9jYWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNQcmV2aWV3OiBuZXh0U3RhdGUuaXNQcmV2aWV3LFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNOb3RGb3VuZDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCd0eXBlJyBpbiByb3V0ZUluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG1pZGRsZXdhcmUgZWZmZWN0IG9uIC80MDRcIiksIFwiX19ORVhUX0VSUk9SX0NPREVcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcIkUxNThcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZyAmJiB0aGlzLnBhdGhuYW1lID09PSAnL19lcnJvcicgJiYgKChfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzID0gc2VsZi5fX05FWFRfREFUQV9fLnByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogKF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHNfcGFnZVByb3BzID0gX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wcy5wYWdlUHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiBfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzX3BhZ2VQcm9wcy5zdGF0dXNDb2RlKSA9PT0gNTAwICYmICgoX3JvdXRlSW5mb19wcm9wcyA9IHJvdXRlSW5mby5wcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9yb3V0ZUluZm9fcHJvcHMucGFnZVByb3BzKSkge1xuICAgICAgICAgICAgICAgIC8vIGVuc3VyZSBzdGF0dXNDb2RlIGlzIHN0aWxsIGNvcnJlY3QgZm9yIHN0YXRpYyA1MDAgcGFnZVxuICAgICAgICAgICAgICAgIC8vIHdoZW4gdXBkYXRpbmcgcXVlcnkgaW5mb3JtYXRpb25cbiAgICAgICAgICAgICAgICByb3V0ZUluZm8ucHJvcHMucGFnZVByb3BzLnN0YXR1c0NvZGUgPSA1MDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX3JvdXRlSW5mb19yb3V0ZTtcbiAgICAgICAgICAgIC8vIHNoYWxsb3cgcm91dGluZyBpcyBvbmx5IGFsbG93ZWQgZm9yIHNhbWUgcGFnZSBVUkwgY2hhbmdlcy5cbiAgICAgICAgICAgIGNvbnN0IGlzVmFsaWRTaGFsbG93Um91dGUgPSBvcHRpb25zLnNoYWxsb3cgJiYgbmV4dFN0YXRlLnJvdXRlID09PSAoKF9yb3V0ZUluZm9fcm91dGUgPSByb3V0ZUluZm8ucm91dGUpICE9IG51bGwgPyBfcm91dGVJbmZvX3JvdXRlIDogcm91dGUpO1xuICAgICAgICAgICAgdmFyIF9vcHRpb25zX3Njcm9sbDtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZFNjcm9sbCA9IChfb3B0aW9uc19zY3JvbGwgPSBvcHRpb25zLnNjcm9sbCkgIT0gbnVsbCA/IF9vcHRpb25zX3Njcm9sbCA6ICFpc1F1ZXJ5VXBkYXRpbmcgJiYgIWlzVmFsaWRTaGFsbG93Um91dGU7XG4gICAgICAgICAgICBjb25zdCByZXNldFNjcm9sbCA9IHNob3VsZFNjcm9sbCA/IHtcbiAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICAgIH0gOiBudWxsO1xuICAgICAgICAgICAgY29uc3QgdXBjb21pbmdTY3JvbGxTdGF0ZSA9IGZvcmNlZFNjcm9sbCAhPSBudWxsID8gZm9yY2VkU2Nyb2xsIDogcmVzZXRTY3JvbGw7XG4gICAgICAgICAgICAvLyB0aGUgbmV3IHN0YXRlIHRoYXQgdGhlIHJvdXRlciBnb25uYSBzZXRcbiAgICAgICAgICAgIGNvbnN0IHVwY29taW5nUm91dGVyU3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgLi4ubmV4dFN0YXRlLFxuICAgICAgICAgICAgICAgIHJvdXRlLFxuICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgIGFzUGF0aDogY2xlYW5lZEFzLFxuICAgICAgICAgICAgICAgIGlzRmFsbGJhY2s6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gV2hlbiB0aGUgcGFnZSBiZWluZyByZW5kZXJlZCBpcyB0aGUgNDA0IHBhZ2UsIHdlIHNob3VsZCBvbmx5IHVwZGF0ZSB0aGVcbiAgICAgICAgICAgIC8vIHF1ZXJ5IHBhcmFtZXRlcnMuIFJvdXRlIGNoYW5nZXMgaGVyZSBtaWdodCBhZGQgdGhlIGJhc2VQYXRoIHdoZW4gaXRcbiAgICAgICAgICAgIC8vIHdhc24ndCBvcmlnaW5hbGx5IHByZXNlbnQuIFRoaXMgaXMgYWxzbyB3aHkgdGhpcyBibG9jayBpcyBiZWZvcmUgdGhlXG4gICAgICAgICAgICAvLyBiZWxvdyBgY2hhbmdlU3RhdGVgIGNhbGwgd2hpY2ggdXBkYXRlcyB0aGUgYnJvd3NlcidzIGhpc3RvcnkgKGNoYW5naW5nXG4gICAgICAgICAgICAvLyB0aGUgVVJMKS5cbiAgICAgICAgICAgIGlmIChpc1F1ZXJ5VXBkYXRpbmcgJiYgaXNFcnJvclJvdXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHNfcGFnZVByb3BzMSwgX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wczEsIF9yb3V0ZUluZm9fcHJvcHMxO1xuICAgICAgICAgICAgICAgIHJvdXRlSW5mbyA9IGF3YWl0IHRoaXMuZ2V0Um91dGVJbmZvKHtcbiAgICAgICAgICAgICAgICAgICAgcm91dGU6IHRoaXMucGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lOiB0aGlzLnBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgYXMsXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlUHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYWxsb3c6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZTogbmV4dFN0YXRlLmxvY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgaXNQcmV2aWV3OiBuZXh0U3RhdGUuaXNQcmV2aWV3LFxuICAgICAgICAgICAgICAgICAgICBpc1F1ZXJ5VXBkYXRpbmc6IGlzUXVlcnlVcGRhdGluZyAmJiAhdGhpcy5pc0ZhbGxiYWNrXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCd0eXBlJyBpbiByb3V0ZUluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgbWlkZGxld2FyZSBlZmZlY3Qgb24gXCIgKyB0aGlzLnBhdGhuYW1lKSwgXCJfX05FWFRfRVJST1JfQ09ERVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCJFMjI1XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGF0aG5hbWUgPT09ICcvX2Vycm9yJyAmJiAoKF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHMxID0gc2VsZi5fX05FWFRfREFUQV9fLnByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogKF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHNfcGFnZVByb3BzMSA9IF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHMxLnBhZ2VQcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHNfcGFnZVByb3BzMS5zdGF0dXNDb2RlKSA9PT0gNTAwICYmICgoX3JvdXRlSW5mb19wcm9wczEgPSByb3V0ZUluZm8ucHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiBfcm91dGVJbmZvX3Byb3BzMS5wYWdlUHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVuc3VyZSBzdGF0dXNDb2RlIGlzIHN0aWxsIGNvcnJlY3QgZm9yIHN0YXRpYyA1MDAgcGFnZVxuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIHVwZGF0aW5nIHF1ZXJ5IGluZm9ybWF0aW9uXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcy5wYWdlUHJvcHMuc3RhdHVzQ29kZSA9IDUwMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXQodXBjb21pbmdSb3V0ZXJTdGF0ZSwgcm91dGVJbmZvLCB1cGNvbWluZ1Njcm9sbFN0YXRlKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBfaXNlcnJvci5kZWZhdWx0KShlcnIpICYmIGVyci5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VFcnJvcicsIGVyciwgY2xlYW5lZEFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdiZWZvcmVIaXN0b3J5Q2hhbmdlJywgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShtZXRob2QsIHVybCwgYXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgLy8gZm9yIHF1ZXJ5IHVwZGF0ZXMgd2UgY2FuIHNraXAgaXQgaWYgdGhlIHN0YXRlIGlzIHVuY2hhbmdlZCBhbmQgd2UgZG9uJ3RcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gc2Nyb2xsXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanMvaXNzdWVzLzM3MTM5XG4gICAgICAgICAgICBjb25zdCBjYW5Ta2lwVXBkYXRpbmcgPSBpc1F1ZXJ5VXBkYXRpbmcgJiYgIXVwY29taW5nU2Nyb2xsU3RhdGUgJiYgIXJlYWR5U3RhdGVDaGFuZ2UgJiYgIWxvY2FsZUNoYW5nZSAmJiAoMCwgX2NvbXBhcmVzdGF0ZXMuY29tcGFyZVJvdXRlclN0YXRlcykodXBjb21pbmdSb3V0ZXJTdGF0ZSwgdGhpcy5zdGF0ZSk7XG4gICAgICAgICAgICBpZiAoIWNhblNraXBVcGRhdGluZykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0KHVwY29taW5nUm91dGVyU3RhdGUsIHJvdXRlSW5mbywgdXBjb21pbmdTY3JvbGxTdGF0ZSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5jYW5jZWxsZWQpIHJvdXRlSW5mby5lcnJvciA9IHJvdXRlSW5mby5lcnJvciB8fCBlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyb3V0ZUluZm8uZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VFcnJvcicsIHJvdXRlSW5mby5lcnJvciwgY2xlYW5lZEFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyByb3V0ZUluZm8uZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0U3RhdGUubG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubGFuZyA9IG5leHRTdGF0ZS5sb2NhbGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUNvbXBsZXRlJywgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBIGhhc2ggbWFyayAjIGlzIHRoZSBvcHRpb25hbCBsYXN0IHBhcnQgb2YgYSBVUkxcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNoUmVnZXggPSAvIy4rJC87XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFNjcm9sbCAmJiBoYXNoUmVnZXgudGVzdChhcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUb0hhc2goYXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmICgoMCwgX2lzZXJyb3IuZGVmYXVsdCkoZXJyKSAmJiBlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSBvcHRpb25zID0ge307XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5oaXN0b3J5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJXYXJuaW5nOiB3aW5kb3cuaGlzdG9yeSBpcyBub3QgYXZhaWxhYmxlLlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5oaXN0b3J5W21ldGhvZF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIldhcm5pbmc6IHdpbmRvdy5oaXN0b3J5LlwiICsgbWV0aG9kICsgXCIgaXMgbm90IGF2YWlsYWJsZVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGhvZCAhPT0gJ3B1c2hTdGF0ZScgfHwgKDAsIF91dGlscy5nZXRVUkwpKCkgIT09IGFzKSB7XG4gICAgICAgICAgICB0aGlzLl9zaGFsbG93ID0gb3B0aW9ucy5zaGFsbG93O1xuICAgICAgICAgICAgd2luZG93Lmhpc3RvcnlbbWV0aG9kXSh7XG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIGFzLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgX19OOiB0cnVlLFxuICAgICAgICAgICAgICAgIGtleTogdGhpcy5fa2V5ID0gbWV0aG9kICE9PSAncHVzaFN0YXRlJyA/IHRoaXMuX2tleSA6IGNyZWF0ZUtleSgpXG4gICAgICAgICAgICB9LCAvLyBNb3N0IGJyb3dzZXJzIGN1cnJlbnRseSBpZ25vcmVzIHRoaXMgcGFyYW1ldGVyLCBhbHRob3VnaCB0aGV5IG1heSB1c2UgaXQgaW4gdGhlIGZ1dHVyZS5cbiAgICAgICAgICAgIC8vIFBhc3NpbmcgdGhlIGVtcHR5IHN0cmluZyBoZXJlIHNob3VsZCBiZSBzYWZlIGFnYWluc3QgZnV0dXJlIGNoYW5nZXMgdG8gdGhlIG1ldGhvZC5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9IaXN0b3J5L3JlcGxhY2VTdGF0ZVxuICAgICAgICAgICAgJycsIGFzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBoYW5kbGVSb3V0ZUluZm9FcnJvcihlcnIsIHBhdGhuYW1lLCBxdWVyeSwgYXMsIHJvdXRlUHJvcHMsIGxvYWRFcnJvckZhaWwpIHtcbiAgICAgICAgaWYgKGVyci5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIC8vIGJ1YmJsZSB1cCBjYW5jZWxsYXRpb24gZXJyb3JzXG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCBfcm91dGVsb2FkZXIuaXNBc3NldEVycm9yKShlcnIpIHx8IGxvYWRFcnJvckZhaWwpIHtcbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VFcnJvcicsIGVyciwgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgLy8gSWYgd2UgY2FuJ3QgbG9hZCB0aGUgcGFnZSBpdCBjb3VsZCBiZSBvbmUgb2YgZm9sbG93aW5nIHJlYXNvbnNcbiAgICAgICAgICAgIC8vICAxLiBQYWdlIGRvZXNuJ3QgZXhpc3RzXG4gICAgICAgICAgICAvLyAgMi4gUGFnZSBkb2VzIGV4aXN0IGluIGEgZGlmZmVyZW50IHpvbmVcbiAgICAgICAgICAgIC8vICAzLiBJbnRlcm5hbCBlcnJvciB3aGlsZSBsb2FkaW5nIHRoZSBwYWdlXG4gICAgICAgICAgICAvLyBTbywgZG9pbmcgYSBoYXJkIHJlbG9hZCBpcyB0aGUgcHJvcGVyIHdheSB0byBkZWFsIHdpdGggdGhpcy5cbiAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICB1cmw6IGFzLFxuICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBDaGFuZ2luZyB0aGUgVVJMIGRvZXNuJ3QgYmxvY2sgZXhlY3V0aW5nIHRoZSBjdXJyZW50IGNvZGUgcGF0aC5cbiAgICAgICAgICAgIC8vIFNvIGxldCdzIHRocm93IGEgY2FuY2VsbGF0aW9uIGVycm9yIHN0b3AgdGhlIHJvdXRpbmcgbG9naWMuXG4gICAgICAgICAgICB0aHJvdyBidWlsZENhbmNlbGxhdGlvbkVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHByb3BzO1xuICAgICAgICAgICAgY29uc3QgeyBwYWdlOiBDb21wb25lbnQsIHN0eWxlU2hlZXRzIH0gPSBhd2FpdCB0aGlzLmZldGNoQ29tcG9uZW50KCcvX2Vycm9yJyk7XG4gICAgICAgICAgICBjb25zdCByb3V0ZUluZm8gPSB7XG4gICAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRzLFxuICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKCFyb3V0ZUluZm8ucHJvcHMpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByb3V0ZUluZm8ucHJvcHMgPSBhd2FpdCB0aGlzLmdldEluaXRpYWxQcm9wcyhDb21wb25lbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZ2lwRXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGVycm9yIHBhZ2UgYGdldEluaXRpYWxQcm9wc2A6ICcsIGdpcEVycik7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByb3V0ZUluZm87XG4gICAgICAgIH0gY2F0Y2ggKHJvdXRlSW5mb0Vycikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUm91dGVJbmZvRXJyb3IoKDAsIF9pc2Vycm9yLmRlZmF1bHQpKHJvdXRlSW5mb0VycikgPyByb3V0ZUluZm9FcnIgOiBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3IEVycm9yKHJvdXRlSW5mb0VyciArICcnKSwgXCJfX05FWFRfRVJST1JfQ09ERVwiLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IFwiRTM5NFwiLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSksIHBhdGhuYW1lLCBxdWVyeSwgYXMsIHJvdXRlUHJvcHMsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFJvdXRlSW5mbyhwYXJhbSkge1xuICAgICAgICBsZXQgeyByb3V0ZTogcmVxdWVzdGVkUm91dGUsIHBhdGhuYW1lLCBxdWVyeSwgYXMsIHJlc29sdmVkQXMsIHJvdXRlUHJvcHMsIGxvY2FsZSwgaGFzTWlkZGxld2FyZSwgaXNQcmV2aWV3LCB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUsIGlzUXVlcnlVcGRhdGluZywgaXNNaWRkbGV3YXJlUmV3cml0ZSwgaXNOb3RGb3VuZCB9ID0gcGFyYW07XG4gICAgICAgIC8qKlxuICAgICAqIFRoaXMgYHJvdXRlYCBiaW5kaW5nIGNhbiBjaGFuZ2UgaWYgdGhlcmUncyBhIHJld3JpdGVcbiAgICAgKiBzbyB3ZSBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBvcmlnaW5hbCByZXF1ZXN0ZWQgcm91dGVcbiAgICAgKiBzbyB3ZSBjYW4gc3RvcmUgdGhlIGNhY2hlIGZvciBpdCBhbmQgYXZvaWQgcmUtcmVxdWVzdGluZyBldmVyeSB0aW1lXG4gICAgICogZm9yIHNoYWxsb3cgcm91dGluZyBwdXJwb3Nlcy5cbiAgICAgKi8gbGV0IHJvdXRlID0gcmVxdWVzdGVkUm91dGU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgX2RhdGFfZWZmZWN0LCBfZGF0YV9lZmZlY3QxLCBfZGF0YV9lZmZlY3QyLCBfZGF0YV9yZXNwb25zZTtcbiAgICAgICAgICAgIGxldCBleGlzdGluZ0luZm8gPSB0aGlzLmNvbXBvbmVudHNbcm91dGVdO1xuICAgICAgICAgICAgaWYgKHJvdXRlUHJvcHMuc2hhbGxvdyAmJiBleGlzdGluZ0luZm8gJiYgdGhpcy5yb3V0ZSA9PT0gcm91dGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGFuZGxlQ2FuY2VsbGVkID0gZ2V0Q2FuY2VsbGVkSGFuZGxlcih7XG4gICAgICAgICAgICAgICAgcm91dGUsXG4gICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChoYXNNaWRkbGV3YXJlKSB7XG4gICAgICAgICAgICAgICAgZXhpc3RpbmdJbmZvID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNhY2hlZFJvdXRlSW5mbyA9IGV4aXN0aW5nSW5mbyAmJiAhKCdpbml0aWFsJyBpbiBleGlzdGluZ0luZm8pICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAnZGV2ZWxvcG1lbnQnID8gZXhpc3RpbmdJbmZvIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgaXNCYWNrZ3JvdW5kID0gaXNRdWVyeVVwZGF0aW5nO1xuICAgICAgICAgICAgY29uc3QgZmV0Y2hOZXh0RGF0YVBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBkYXRhSHJlZjogdGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKHtcbiAgICAgICAgICAgICAgICAgICAgaHJlZjogKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIHNraXBJbnRlcnBvbGF0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhc1BhdGg6IGlzTm90Rm91bmQgPyAnLzQwNCcgOiByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbGVcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBoYXNNaWRkbGV3YXJlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGlzU2VydmVyUmVuZGVyOiB0aGlzLmlzU3NyLFxuICAgICAgICAgICAgICAgIHBhcnNlSlNPTjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbmZsaWdodENhY2hlOiBpc0JhY2tncm91bmQgPyB0aGlzLnNiYyA6IHRoaXMuc2RjLFxuICAgICAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogIWlzUHJldmlldyxcbiAgICAgICAgICAgICAgICBpc1ByZWZldGNoOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUsXG4gICAgICAgICAgICAgICAgaXNCYWNrZ3JvdW5kXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IGRhdGEgPSBpc1F1ZXJ5VXBkYXRpbmcgJiYgIWlzTWlkZGxld2FyZVJld3JpdGUgPyBudWxsIDogYXdhaXQgd2l0aE1pZGRsZXdhcmVFZmZlY3RzKHtcbiAgICAgICAgICAgICAgICBmZXRjaERhdGE6ICgpPT5mZXRjaE5leHREYXRhKGZldGNoTmV4dERhdGFQYXJhbXMpLFxuICAgICAgICAgICAgICAgIGFzUGF0aDogaXNOb3RGb3VuZCA/ICcvNDA0JyA6IHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgbG9jYWxlOiBsb2NhbGUsXG4gICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IGhhcmQgZXJyb3IgZHVyaW5nIHF1ZXJ5IHVwZGF0aW5nXG4gICAgICAgICAgICAgICAgLy8gYXMgaXQncyB1bi1uZWNlc3NhcnkgYW5kIGRvZXNuJ3QgbmVlZCB0byBiZSBmYXRhbFxuICAgICAgICAgICAgICAgIC8vIHVubGVzcyBpdCBpcyBhIGZhbGxiYWNrIHJvdXRlIGFuZCB0aGUgcHJvcHMgY2FuJ3RcbiAgICAgICAgICAgICAgICAvLyBiZSBsb2FkZWRcbiAgICAgICAgICAgICAgICBpZiAoaXNRdWVyeVVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHdoZW4gcmVuZGVyaW5nIGVycm9yIHJvdXRlcyB3ZSBkb24ndCBhcHBseSBtaWRkbGV3YXJlXG4gICAgICAgICAgICAvLyBlZmZlY3RzXG4gICAgICAgICAgICBpZiAoZGF0YSAmJiAocGF0aG5hbWUgPT09ICcvX2Vycm9yJyB8fCBwYXRobmFtZSA9PT0gJy80MDQnKSkge1xuICAgICAgICAgICAgICAgIGRhdGEuZWZmZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZykge1xuICAgICAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAganNvbjogc2VsZi5fX05FWFRfREFUQV9fLnByb3BzXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5qc29uID0gc2VsZi5fX05FWFRfREFUQV9fLnByb3BzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhbmRsZUNhbmNlbGxlZCgpO1xuICAgICAgICAgICAgaWYgKChkYXRhID09IG51bGwgPyB2b2lkIDAgOiAoX2RhdGFfZWZmZWN0ID0gZGF0YS5lZmZlY3QpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YV9lZmZlY3QudHlwZSkgPT09ICdyZWRpcmVjdC1pbnRlcm5hbCcgfHwgKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IChfZGF0YV9lZmZlY3QxID0gZGF0YS5lZmZlY3QpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YV9lZmZlY3QxLnR5cGUpID09PSAncmVkaXJlY3QtZXh0ZXJuYWwnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuZWZmZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChkYXRhID09IG51bGwgPyB2b2lkIDAgOiAoX2RhdGFfZWZmZWN0MiA9IGRhdGEuZWZmZWN0KSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGFfZWZmZWN0Mi50eXBlKSA9PT0gJ3Jld3JpdGUnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRSb3V0ZSA9ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShkYXRhLmVmZmVjdC5yZXNvbHZlZEhyZWYpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhZ2VzID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KCk7XG4gICAgICAgICAgICAgICAgLy8gZHVyaW5nIHF1ZXJ5IHVwZGF0aW5nIHRoZSBwYWdlIG11c3QgbWF0Y2ggYWx0aG91Z2ggZHVyaW5nXG4gICAgICAgICAgICAgICAgLy8gY2xpZW50LXRyYW5zaXRpb24gYSByZWRpcmVjdCB0aGF0IGRvZXNuJ3QgbWF0Y2ggYSBwYWdlXG4gICAgICAgICAgICAgICAgLy8gY2FuIGJlIHJldHVybmVkIGFuZCB0aGlzIHNob3VsZCB0cmlnZ2VyIGEgaGFyZCBuYXZpZ2F0aW9uXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggaXMgdmFsaWQgZm9yIGluY3JlbWVudGFsIG1pZ3JhdGlvblxuICAgICAgICAgICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nIHx8IHBhZ2VzLmluY2x1ZGVzKHJlc29sdmVkUm91dGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlID0gcmVzb2x2ZWRSb3V0ZTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUgPSBkYXRhLmVmZmVjdC5yZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ucXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5kYXRhLmVmZmVjdC5wYXJzZWRBcy5xdWVyeVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZEFzID0gKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkoKDAsIF9ub3JtYWxpemVsb2NhbGVwYXRoLm5vcm1hbGl6ZUxvY2FsZVBhdGgpKGRhdGEuZWZmZWN0LnBhcnNlZEFzLnBhdGhuYW1lLCB0aGlzLmxvY2FsZXMpLnBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgYWdhaW4gdGhlIGNhY2hlIHdpdGggdGhlIG5ldyBkZXN0aW5hdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdJbmZvID0gdGhpcy5jb21wb25lbnRzW3JvdXRlXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvdXRlUHJvcHMuc2hhbGxvdyAmJiBleGlzdGluZ0luZm8gJiYgdGhpcy5yb3V0ZSA9PT0gcm91dGUgJiYgIWhhc01pZGRsZXdhcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBtYXRjaCB3aXRoIHRoZSBjdXJyZW50IHJvdXRlIGR1ZSB0byByZXdyaXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgY2FuIGNvcHkgdGhlIGV4aXN0aW5nIGluZm9ybWF0aW9uIHRvIHRoZSByZXdyaXR0ZW4gb25lLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlbiwgd2UgcmV0dXJuIHRoZSBpbmZvcm1hdGlvbiBhbG9uZyB3aXRoIHRoZSBtYXRjaGVkIHJvdXRlLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5leGlzdGluZ0luZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKDAsIF9pc2FwaXJvdXRlLmlzQVBJUm91dGUpKHJvdXRlKSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBhcyxcbiAgICAgICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByb3V0ZUluZm8gPSBjYWNoZWRSb3V0ZUluZm8gfHwgYXdhaXQgdGhpcy5mZXRjaENvbXBvbmVudChyb3V0ZSkudGhlbigocmVzKT0+KHtcbiAgICAgICAgICAgICAgICAgICAgQ29tcG9uZW50OiByZXMucGFnZSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVTaGVldHM6IHJlcy5zdHlsZVNoZWV0cyxcbiAgICAgICAgICAgICAgICAgICAgX19OX1NTRzogcmVzLm1vZC5fX05fU1NHLFxuICAgICAgICAgICAgICAgICAgICBfX05fU1NQOiByZXMubW9kLl9fTl9TU1BcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaXNWYWxpZEVsZW1lbnRUeXBlIH0gPSByZXF1aXJlKCduZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtaXMnKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRFbGVtZW50VHlwZShyb3V0ZUluZm8uQ29tcG9uZW50KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3IEVycm9yKCdUaGUgZGVmYXVsdCBleHBvcnQgaXMgbm90IGEgUmVhY3QgQ29tcG9uZW50IGluIHBhZ2U6IFwiJyArIHBhdGhuYW1lICsgJ1wiJyksIFwiX19ORVhUX0VSUk9SX0NPREVcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFwiRTI4NlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgd2FzQmFpbGVkUHJlZmV0Y2ggPSBkYXRhID09IG51bGwgPyB2b2lkIDAgOiAoX2RhdGFfcmVzcG9uc2UgPSBkYXRhLnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGFfcmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtbWlkZGxld2FyZS1za2lwJyk7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRGZXRjaERhdGEgPSByb3V0ZUluZm8uX19OX1NTRyB8fCByb3V0ZUluZm8uX19OX1NTUDtcbiAgICAgICAgICAgIC8vIEZvciBub24tU1NHIHByZWZldGNoZXMgdGhhdCBiYWlsZWQgYmVmb3JlIHNlbmRpbmcgZGF0YVxuICAgICAgICAgICAgLy8gd2UgY2xlYXIgdGhlIGNhY2hlIHRvIGZldGNoIGZ1bGwgcmVzcG9uc2VcbiAgICAgICAgICAgIGlmICh3YXNCYWlsZWRQcmVmZXRjaCAmJiAoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5kYXRhSHJlZikpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zZGNbZGF0YS5kYXRhSHJlZl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHByb3BzLCBjYWNoZUtleSB9ID0gYXdhaXQgdGhpcy5fZ2V0RGF0YShhc3luYyAoKT0+e1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRGZXRjaERhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmpzb24pICYmICF3YXNCYWlsZWRQcmVmZXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUtleTogZGF0YS5jYWNoZUtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wczogZGF0YS5qc29uXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFIcmVmID0gKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuZGF0YUhyZWYpID8gZGF0YS5kYXRhSHJlZiA6IHRoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZih7XG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmOiAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzUGF0aDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmV0Y2hlZCA9IGF3YWl0IGZldGNoTmV4dERhdGEoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1NlcnZlclJlbmRlcjogdGhpcy5pc1NzcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlSlNPTjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IHdhc0JhaWxlZFByZWZldGNoID8ge30gOiB0aGlzLnNkYyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogIWlzUHJldmlldyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUHJlZmV0Y2g6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdW5zdGFibGVfc2tpcENsaWVudENhY2hlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXk6IGZldGNoZWQuY2FjaGVLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wczogZmV0Y2hlZC5qc29uIHx8IHt9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgICAgICAgICBwcm9wczogYXdhaXQgdGhpcy5nZXRJbml0aWFsUHJvcHMocm91dGVJbmZvLkNvbXBvbmVudCwgLy8gd2UgcHJvdmlkZSBBcHBUcmVlIGxhdGVyIHNvIHRoaXMgbmVlZHMgdG8gYmUgYGFueWBcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzUGF0aDogYXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVzOiB0aGlzLmxvY2FsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0TG9jYWxlOiB0aGlzLmRlZmF1bHRMb2NhbGVcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBPbmx5IGJ1c3QgdGhlIGRhdGEgY2FjaGUgZm9yIFNTUCByb3V0ZXMgYWx0aG91Z2hcbiAgICAgICAgICAgIC8vIG1pZGRsZXdhcmUgY2FuIHNraXAgY2FjaGUgcGVyIHJlcXVlc3Qgd2l0aFxuICAgICAgICAgICAgLy8geC1taWRkbGV3YXJlLWNhY2hlOiBuby1jYWNoZSBhcyB3ZWxsXG4gICAgICAgICAgICBpZiAocm91dGVJbmZvLl9fTl9TU1AgJiYgZmV0Y2hOZXh0RGF0YVBhcmFtcy5kYXRhSHJlZiAmJiBjYWNoZUtleSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNkY1tjYWNoZUtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB3ZSBraWNrIG9mZiBhIEhFQUQgcmVxdWVzdCBpbiB0aGUgYmFja2dyb3VuZFxuICAgICAgICAgICAgLy8gd2hlbiBhIG5vbi1wcmVmZXRjaCByZXF1ZXN0IGlzIG1hZGUgdG8gc2lnbmFsIHJldmFsaWRhdGlvblxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzUHJldmlldyAmJiByb3V0ZUluZm8uX19OX1NTRyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ2RldmVsb3BtZW50JyAmJiAhaXNRdWVyeVVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgZmV0Y2hOZXh0RGF0YShPYmplY3QuYXNzaWduKHt9LCBmZXRjaE5leHREYXRhUGFyYW1zLCB7XG4gICAgICAgICAgICAgICAgICAgIGlzQmFja2dyb3VuZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcGVyc2lzdENhY2hlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRDYWNoZTogdGhpcy5zYmNcbiAgICAgICAgICAgICAgICB9KSkuY2F0Y2goKCk9Pnt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb3BzLnBhZ2VQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIHByb3BzLnBhZ2VQcm9wcyk7XG4gICAgICAgICAgICByb3V0ZUluZm8ucHJvcHMgPSBwcm9wcztcbiAgICAgICAgICAgIHJvdXRlSW5mby5yb3V0ZSA9IHJvdXRlO1xuICAgICAgICAgICAgcm91dGVJbmZvLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgICAgICByb3V0ZUluZm8ucmVzb2x2ZWRBcyA9IHJlc29sdmVkQXM7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHNbcm91dGVdID0gcm91dGVJbmZvO1xuICAgICAgICAgICAgcmV0dXJuIHJvdXRlSW5mbztcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVSb3V0ZUluZm9FcnJvcigoMCwgX2lzZXJyb3IuZ2V0UHJvcGVyRXJyb3IpKGVyciksIHBhdGhuYW1lLCBxdWVyeSwgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldChzdGF0ZSwgZGF0YSwgcmVzZXRTY3JvbGwpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICByZXR1cm4gdGhpcy5zdWIoZGF0YSwgdGhpcy5jb21wb25lbnRzWycvX2FwcCddLkNvbXBvbmVudCwgcmVzZXRTY3JvbGwpO1xuICAgIH1cbiAgICAvKipcbiAgICogQ2FsbGJhY2sgdG8gZXhlY3V0ZSBiZWZvcmUgcmVwbGFjaW5nIHJvdXRlciBzdGF0ZVxuICAgKiBAcGFyYW0gY2IgY2FsbGJhY2sgdG8gYmUgZXhlY3V0ZWRcbiAgICovIGJlZm9yZVBvcFN0YXRlKGNiKSB7XG4gICAgICAgIHRoaXMuX2JwcyA9IGNiO1xuICAgIH1cbiAgICBvbmx5QUhhc2hDaGFuZ2UoYXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFzUGF0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBbb2xkVXJsTm9IYXNoLCBvbGRIYXNoXSA9IHRoaXMuYXNQYXRoLnNwbGl0KCcjJywgMik7XG4gICAgICAgIGNvbnN0IFtuZXdVcmxOb0hhc2gsIG5ld0hhc2hdID0gYXMuc3BsaXQoJyMnLCAyKTtcbiAgICAgICAgLy8gTWFrZXMgc3VyZSB3ZSBzY3JvbGwgdG8gdGhlIHByb3ZpZGVkIGhhc2ggaWYgdGhlIHVybC9oYXNoIGFyZSB0aGUgc2FtZVxuICAgICAgICBpZiAobmV3SGFzaCAmJiBvbGRVcmxOb0hhc2ggPT09IG5ld1VybE5vSGFzaCAmJiBvbGRIYXNoID09PSBuZXdIYXNoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgdXJscyBhcmUgY2hhbmdlLCB0aGVyZSdzIG1vcmUgdGhhbiBhIGhhc2ggY2hhbmdlXG4gICAgICAgIGlmIChvbGRVcmxOb0hhc2ggIT09IG5ld1VybE5vSGFzaCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBoYXNoIGhhcyBjaGFuZ2VkLCB0aGVuIGl0J3MgYSBoYXNoIG9ubHkgY2hhbmdlLlxuICAgICAgICAvLyBUaGlzIGNoZWNrIGlzIG5lY2Vzc2FyeSB0byBoYW5kbGUgYm90aCB0aGUgZW50ZXIgYW5kXG4gICAgICAgIC8vIGxlYXZlIGhhc2ggPT09ICcnIGNhc2VzLiBUaGUgaWRlbnRpdHkgY2FzZSBmYWxscyB0aHJvdWdoXG4gICAgICAgIC8vIGFuZCBpcyB0cmVhdGVkIGFzIGEgbmV4dCByZWxvYWQuXG4gICAgICAgIHJldHVybiBvbGRIYXNoICE9PSBuZXdIYXNoO1xuICAgIH1cbiAgICBzY3JvbGxUb0hhc2goYXMpIHtcbiAgICAgICAgY29uc3QgWywgaGFzaCA9ICcnXSA9IGFzLnNwbGl0KCcjJywgMik7XG4gICAgICAgICgwLCBfaGFuZGxlc21vb3Roc2Nyb2xsLmhhbmRsZVNtb290aFNjcm9sbCkoKCk9PntcbiAgICAgICAgICAgIC8vIFNjcm9sbCB0byB0b3AgaWYgdGhlIGhhc2ggaXMganVzdCBgI2Agd2l0aCBubyB2YWx1ZSBvciBgI3RvcGBcbiAgICAgICAgICAgIC8vIFRvIG1pcnJvciBicm93c2Vyc1xuICAgICAgICAgICAgaWYgKGhhc2ggPT09ICcnIHx8IGhhc2ggPT09ICd0b3AnKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsIDApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERlY29kZSBoYXNoIHRvIG1ha2Ugbm9uLWxhdGluIGFuY2hvciB3b3Jrcy5cbiAgICAgICAgICAgIGNvbnN0IHJhd0hhc2ggPSBkZWNvZGVVUklDb21wb25lbnQoaGFzaCk7XG4gICAgICAgICAgICAvLyBGaXJzdCB3ZSBjaGVjayBpZiB0aGUgZWxlbWVudCBieSBpZCBpcyBmb3VuZFxuICAgICAgICAgICAgY29uc3QgaWRFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHJhd0hhc2gpO1xuICAgICAgICAgICAgaWYgKGlkRWwpIHtcbiAgICAgICAgICAgICAgICBpZEVsLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBubyBlbGVtZW50IHdpdGggdGhlIGlkLCB3ZSBjaGVjayB0aGUgYG5hbWVgIHByb3BlcnR5XG4gICAgICAgICAgICAvLyBUbyBtaXJyb3IgYnJvd3NlcnNcbiAgICAgICAgICAgIGNvbnN0IG5hbWVFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKHJhd0hhc2gpWzBdO1xuICAgICAgICAgICAgaWYgKG5hbWVFbCkge1xuICAgICAgICAgICAgICAgIG5hbWVFbC5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBvbmx5SGFzaENoYW5nZTogdGhpcy5vbmx5QUhhc2hDaGFuZ2UoYXMpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1cmxJc05ldyhhc1BhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXNQYXRoICE9PSBhc1BhdGg7XG4gICAgfVxuICAgIC8qKlxuICAgKiBQcmVmZXRjaCBwYWdlIGNvZGUsIHlvdSBtYXkgd2FpdCBmb3IgdGhlIGRhdGEgZHVyaW5nIHBhZ2UgcmVuZGVyaW5nLlxuICAgKiBUaGlzIGZlYXR1cmUgb25seSB3b3JrcyBpbiBwcm9kdWN0aW9uIVxuICAgKiBAcGFyYW0gdXJsIHRoZSBocmVmIG9mIHByZWZldGNoZWQgcGFnZVxuICAgKiBAcGFyYW0gYXNQYXRoIHRoZSBhcyBwYXRoIG9mIHRoZSBwcmVmZXRjaGVkIHBhZ2VcbiAgICovIGFzeW5jIHByZWZldGNoKHVybCwgYXNQYXRoLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChhc1BhdGggPT09IHZvaWQgMCkgYXNQYXRoID0gdXJsO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSBvcHRpb25zID0ge307XG4gICAgICAgIC8vIFByZWZldGNoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gZGV2ZWxvcG1lbnQgbW9kZSBiZWNhdXNlIGl0IHdvdWxkIHRyaWdnZXIgb24tZGVtYW5kLWVudHJpZXNcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgKDAsIF9pc2JvdC5pc0JvdCkod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICAgICAgICAvLyBObyBwcmVmZXRjaGVzIGZvciBib3RzIHRoYXQgcmVuZGVyIHRoZSBsaW5rIHNpbmNlIHRoZXkgYXJlIHR5cGljYWxseSBuYXZpZ2F0aW5nXG4gICAgICAgICAgICAvLyBsaW5rcyB2aWEgdGhlIGVxdWl2YWxlbnQgb2YgYSBoYXJkIG5hdmlnYXRpb24gYW5kIGhlbmNlIG5ldmVyIHV0aWxpemUgdGhlc2VcbiAgICAgICAgICAgIC8vIHByZWZldGNoZXMuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcnNlZCA9ICgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKSh1cmwpO1xuICAgICAgICBjb25zdCB1cmxQYXRobmFtZSA9IHBhcnNlZC5wYXRobmFtZTtcbiAgICAgICAgbGV0IHsgcGF0aG5hbWUsIHF1ZXJ5IH0gPSBwYXJzZWQ7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsUGF0aG5hbWUgPSBwYXRobmFtZTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmxvY2FsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBwYXRobmFtZSA9ICgwLCBfbm9ybWFsaXplbG9jYWxlcGF0aC5ub3JtYWxpemVMb2NhbGVQYXRoKShwYXRobmFtZSwgdGhpcy5sb2NhbGVzKS5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBwYXRobmFtZTtcbiAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikocGFyc2VkKTtcbiAgICAgICAgICAgICAgICBsZXQgcGFyc2VkQXMgPSAoMCwgX3BhcnNlcmVsYXRpdmV1cmwucGFyc2VSZWxhdGl2ZVVybCkoYXNQYXRoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbGVQYXRoUmVzdWx0ID0gKDAsIF9ub3JtYWxpemVsb2NhbGVwYXRoLm5vcm1hbGl6ZUxvY2FsZVBhdGgpKHBhcnNlZEFzLnBhdGhuYW1lLCB0aGlzLmxvY2FsZXMpO1xuICAgICAgICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gbG9jYWxlUGF0aFJlc3VsdC5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmxvY2FsZSA9IGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGUgfHwgdGhpcy5kZWZhdWx0TG9jYWxlO1xuICAgICAgICAgICAgICAgIGFzUGF0aCA9ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShwYXJzZWRBcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFnZXMgPSBhd2FpdCB0aGlzLnBhZ2VMb2FkZXIuZ2V0UGFnZUxpc3QoKTtcbiAgICAgICAgbGV0IHJlc29sdmVkQXMgPSBhc1BhdGg7XG4gICAgICAgIGNvbnN0IGxvY2FsZSA9IHR5cGVvZiBvcHRpb25zLmxvY2FsZSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmxvY2FsZSB8fCB1bmRlZmluZWQgOiB0aGlzLmxvY2FsZTtcbiAgICAgICAgY29uc3QgaXNNaWRkbGV3YXJlTWF0Y2ggPSBhd2FpdCBtYXRjaGVzTWlkZGxld2FyZSh7XG4gICAgICAgICAgICBhc1BhdGg6IGFzUGF0aCxcbiAgICAgICAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUyAmJiBhc1BhdGguc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICBsZXQgcmV3cml0ZXM7XG4gICAgICAgICAgICAoeyBfX3Jld3JpdGVzOiByZXdyaXRlcyB9ID0gYXdhaXQgKDAsIF9yb3V0ZWxvYWRlci5nZXRDbGllbnRCdWlsZE1hbmlmZXN0KSgpKTtcbiAgICAgICAgICAgIGNvbnN0IHJld3JpdGVzUmVzdWx0ID0gKDAsIF9yZXNvbHZlcmV3cml0ZXMuZGVmYXVsdCkoKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkoKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKShhc1BhdGgsIHRoaXMubG9jYWxlKSwgdHJ1ZSksIHBhZ2VzLCByZXdyaXRlcywgcGFyc2VkLnF1ZXJ5LCAocCk9PnJlc29sdmVEeW5hbWljUm91dGUocCwgcGFnZXMpLCB0aGlzLmxvY2FsZXMpO1xuICAgICAgICAgICAgaWYgKHJld3JpdGVzUmVzdWx0LmV4dGVybmFsRGVzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlZEFzID0gKDAsIF9yZW1vdmVsb2NhbGUucmVtb3ZlTG9jYWxlKSgoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShyZXdyaXRlc1Jlc3VsdC5hc1BhdGgpLCB0aGlzLmxvY2FsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmV3cml0ZXNSZXN1bHQubWF0Y2hlZFBhZ2UgJiYgcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBkaXJlY3RseSBtYXRjaGVzIGEgcGFnZSB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgaHJlZiB0b1xuICAgICAgICAgICAgICAgIC8vIGFsbG93IHRoZSBjb3JyZWN0IHBhZ2UgY2h1bmsgdG8gYmUgbG9hZGVkXG4gICAgICAgICAgICAgICAgcGF0aG5hbWUgPSByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikocGFyc2VkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXJzZWQucGF0aG5hbWUsIHBhZ2VzKTtcbiAgICAgICAgaWYgKCgwLCBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlKShwYXJzZWQucGF0aG5hbWUpKSB7XG4gICAgICAgICAgICBwYXRobmFtZSA9IHBhcnNlZC5wYXRobmFtZTtcbiAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihxdWVyeSwgKDAsIF9yb3V0ZW1hdGNoZXIuZ2V0Um91dGVNYXRjaGVyKSgoMCwgX3JvdXRlcmVnZXguZ2V0Um91dGVSZWdleCkocGFyc2VkLnBhdGhuYW1lKSkoKDAsIF9wYXJzZXBhdGgucGFyc2VQYXRoKShhc1BhdGgpLnBhdGhuYW1lKSB8fCB7fSk7XG4gICAgICAgICAgICBpZiAoIWlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgdXJsID0gKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHBhcnNlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IHByb2Nlc3MuZW52Ll9fTkVYVF9NSURETEVXQVJFX1BSRUZFVENIID09PSAnc3RyaWN0JyA/IG51bGwgOiBhd2FpdCB3aXRoTWlkZGxld2FyZUVmZmVjdHMoe1xuICAgICAgICAgICAgZmV0Y2hEYXRhOiAoKT0+ZmV0Y2hOZXh0RGF0YSh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFIcmVmOiB0aGlzLnBhZ2VMb2FkZXIuZ2V0RGF0YUhyZWYoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogb3JpZ2luYWxQYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwSW50ZXJwb2xhdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzUGF0aDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgaGFzTWlkZGxld2FyZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaXNTZXJ2ZXJSZW5kZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUpTT046IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IHRoaXMuc2RjLFxuICAgICAgICAgICAgICAgICAgICBwZXJzaXN0Q2FjaGU6ICF0aGlzLmlzUHJldmlldyxcbiAgICAgICAgICAgICAgICAgICAgaXNQcmVmZXRjaDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgYXNQYXRoOiBhc1BhdGgsXG4gICAgICAgICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICogSWYgdGhlcmUgd2FzIGEgcmV3cml0ZSB3ZSBhcHBseSB0aGUgZWZmZWN0cyBvZiB0aGUgcmV3cml0ZSBvbiB0aGVcbiAgICAgKiBjdXJyZW50IHBhcmFtZXRlcnMgZm9yIHRoZSBwcmVmZXRjaC5cbiAgICAgKi8gaWYgKChkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmVmZmVjdC50eXBlKSA9PT0gJ3Jld3JpdGUnKSB7XG4gICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBkYXRhLmVmZmVjdC5yZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICBwYXRobmFtZSA9IGRhdGEuZWZmZWN0LnJlc29sdmVkSHJlZjtcbiAgICAgICAgICAgIHF1ZXJ5ID0ge1xuICAgICAgICAgICAgICAgIC4uLnF1ZXJ5LFxuICAgICAgICAgICAgICAgIC4uLmRhdGEuZWZmZWN0LnBhcnNlZEFzLnF1ZXJ5XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzb2x2ZWRBcyA9IGRhdGEuZWZmZWN0LnBhcnNlZEFzLnBhdGhuYW1lO1xuICAgICAgICAgICAgdXJsID0gKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHBhcnNlZCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICogSWYgdGhlcmUgaXMgYSByZWRpcmVjdCB0byBhbiBleHRlcm5hbCBkZXN0aW5hdGlvbiB0aGVuIHdlIGRvbid0IGhhdmVcbiAgICAgKiB0byBwcmVmZXRjaCBjb250ZW50IGFzIGl0IHdpbGwgYmUgdW51c2VkLlxuICAgICAqLyBpZiAoKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuZWZmZWN0LnR5cGUpID09PSAncmVkaXJlY3QtZXh0ZXJuYWwnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm91dGUgPSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkocGF0aG5hbWUpO1xuICAgICAgICBpZiAoYXdhaXQgdGhpcy5fYmZsKGFzUGF0aCwgcmVzb2x2ZWRBcywgb3B0aW9ucy5sb2NhbGUsIHRydWUpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHNbdXJsUGF0aG5hbWVdID0ge1xuICAgICAgICAgICAgICAgIF9fYXBwUm91dGVyOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHRoaXMucGFnZUxvYWRlci5faXNTc2cocm91dGUpLnRoZW4oKGlzU3NnKT0+e1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1NzZyA/IGZldGNoTmV4dERhdGEoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZjogKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuanNvbikgPyBkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmRhdGFIcmVmIDogdGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzUGF0aDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZTogbG9jYWxlXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBpc1NlcnZlclJlbmRlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSlNPTjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRDYWNoZTogdGhpcy5zZGMsXG4gICAgICAgICAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogIXRoaXMuaXNQcmV2aWV3LFxuICAgICAgICAgICAgICAgICAgICBpc1ByZWZldGNoOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGU6IG9wdGlvbnMudW5zdGFibGVfc2tpcENsaWVudENhY2hlIHx8IG9wdGlvbnMucHJpb3JpdHkgJiYgISFwcm9jZXNzLmVudi5fX05FWFRfT1BUSU1JU1RJQ19DTElFTlRfQ0FDSEVcbiAgICAgICAgICAgICAgICB9KS50aGVuKCgpPT5mYWxzZSkuY2F0Y2goKCk9PmZhbHNlKSA6IGZhbHNlO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0aGlzLnBhZ2VMb2FkZXJbb3B0aW9ucy5wcmlvcml0eSA/ICdsb2FkUGFnZScgOiAncHJlZmV0Y2gnXShyb3V0ZSlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGFzeW5jIGZldGNoQ29tcG9uZW50KHJvdXRlKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZUNhbmNlbGxlZCA9IGdldENhbmNlbGxlZEhhbmRsZXIoe1xuICAgICAgICAgICAgcm91dGUsXG4gICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnRSZXN1bHQgPSBhd2FpdCB0aGlzLnBhZ2VMb2FkZXIubG9hZFBhZ2Uocm91dGUpO1xuICAgICAgICAgICAgaGFuZGxlQ2FuY2VsbGVkKCk7XG4gICAgICAgICAgICByZXR1cm4gY29tcG9uZW50UmVzdWx0O1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGhhbmRsZUNhbmNlbGxlZCgpO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9nZXREYXRhKGZuKSB7XG4gICAgICAgIGxldCBjYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgY2FuY2VsID0gKCk9PntcbiAgICAgICAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2xjID0gY2FuY2VsO1xuICAgICAgICByZXR1cm4gZm4oKS50aGVuKChkYXRhKT0+e1xuICAgICAgICAgICAgaWYgKGNhbmNlbCA9PT0gdGhpcy5jbGMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsYyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ldyBFcnJvcignTG9hZGluZyBpbml0aWFsIHByb3BzIGNhbmNlbGxlZCcpLCBcIl9fTkVYVF9FUlJPUl9DT0RFXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFwiRTQwNVwiLFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZXJyLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRJbml0aWFsUHJvcHMoQ29tcG9uZW50LCBjdHgpIHtcbiAgICAgICAgY29uc3QgeyBDb21wb25lbnQ6IEFwcCB9ID0gdGhpcy5jb21wb25lbnRzWycvX2FwcCddO1xuICAgICAgICBjb25zdCBBcHBUcmVlID0gdGhpcy5fd3JhcEFwcChBcHApO1xuICAgICAgICBjdHguQXBwVHJlZSA9IEFwcFRyZWU7XG4gICAgICAgIHJldHVybiAoMCwgX3V0aWxzLmxvYWRHZXRJbml0aWFsUHJvcHMpKEFwcCwge1xuICAgICAgICAgICAgQXBwVHJlZSxcbiAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgIHJvdXRlcjogdGhpcyxcbiAgICAgICAgICAgIGN0eFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IHJvdXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5yb3V0ZTtcbiAgICB9XG4gICAgZ2V0IHBhdGhuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgZ2V0IHF1ZXJ5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5xdWVyeTtcbiAgICB9XG4gICAgZ2V0IGFzUGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuYXNQYXRoO1xuICAgIH1cbiAgICBnZXQgbG9jYWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5sb2NhbGU7XG4gICAgfVxuICAgIGdldCBpc0ZhbGxiYWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5pc0ZhbGxiYWNrO1xuICAgIH1cbiAgICBnZXQgaXNQcmV2aWV3KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5pc1ByZXZpZXc7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHBhdGhuYW1lLCBxdWVyeSwgYXMsIHsgaW5pdGlhbFByb3BzLCBwYWdlTG9hZGVyLCBBcHAsIHdyYXBBcHAsIENvbXBvbmVudCwgZXJyLCBzdWJzY3JpcHRpb24sIGlzRmFsbGJhY2ssIGxvY2FsZSwgbG9jYWxlcywgZGVmYXVsdExvY2FsZSwgZG9tYWluTG9jYWxlcywgaXNQcmV2aWV3IH0pe1xuICAgICAgICAvLyBTZXJ2ZXIgRGF0YSBDYWNoZSAoZnVsbCBkYXRhIHJlcXVlc3RzKVxuICAgICAgICB0aGlzLnNkYyA9IHt9O1xuICAgICAgICAvLyBTZXJ2ZXIgQmFja2dyb3VuZCBDYWNoZSAoSEVBRCByZXF1ZXN0cylcbiAgICAgICAgdGhpcy5zYmMgPSB7fTtcbiAgICAgICAgdGhpcy5pc0ZpcnN0UG9wU3RhdGVFdmVudCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2tleSA9IGNyZWF0ZUtleSgpO1xuICAgICAgICB0aGlzLm9uUG9wU3RhdGUgPSAoZSk9PntcbiAgICAgICAgICAgIGNvbnN0IHsgaXNGaXJzdFBvcFN0YXRlRXZlbnQgfSA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmlzRmlyc3RQb3BTdGF0ZUV2ZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IGUuc3RhdGU7XG4gICAgICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZ2V0IHN0YXRlIGFzIHVuZGVmaW5lZCBmb3IgdHdvIHJlYXNvbnMuXG4gICAgICAgICAgICAgICAgLy8gIDEuIFdpdGggb2xkZXIgc2FmYXJpICg8IDgpIGFuZCBvbGRlciBjaHJvbWUgKDwgMzQpXG4gICAgICAgICAgICAgICAgLy8gIDIuIFdoZW4gdGhlIFVSTCBjaGFuZ2VkIHdpdGggI1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gSW4gdGhlIGJvdGggY2FzZXMsIHdlIGRvbid0IG5lZWQgdG8gcHJvY2VlZCBhbmQgY2hhbmdlIHRoZSByb3V0ZS5cbiAgICAgICAgICAgICAgICAvLyAoYXMgaXQncyBhbHJlYWR5IGNoYW5nZWQpXG4gICAgICAgICAgICAgICAgLy8gQnV0IHdlIGNhbiBzaW1wbHkgcmVwbGFjZSB0aGUgc3RhdGUgd2l0aCB0aGUgbmV3IGNoYW5nZXMuXG4gICAgICAgICAgICAgICAgLy8gQWN0dWFsbHksIGZvciAoMSkgd2UgZG9uJ3QgbmVlZCB0byBub3RoaW5nLiBCdXQgaXQncyBoYXJkIHRvIGRldGVjdCB0aGF0IGV2ZW50LlxuICAgICAgICAgICAgICAgIC8vIFNvLCBkb2luZyB0aGUgZm9sbG93aW5nIGZvciAoMSkgZG9lcyBubyBoYXJtLlxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGF0aG5hbWUsIHF1ZXJ5IH0gPSB0aGlzO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoJ3JlcGxhY2VTdGF0ZScsICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKSh7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lOiAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKShwYXRobmFtZSksXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgICAgICAgfSksICgwLCBfdXRpbHMuZ2V0VVJMKSgpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBfX05BIGlzIHVzZWQgdG8gaWRlbnRpZnkgaWYgdGhlIGhpc3RvcnkgZW50cnkgY2FuIGJlIGhhbmRsZWQgYnkgdGhlIGFwcC1yb3V0ZXIuXG4gICAgICAgICAgICBpZiAoc3RhdGUuX19OQSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN0YXRlLl9fTikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNhZmFyaSBmaXJlcyBwb3BzdGF0ZWV2ZW50IHdoZW4gcmVvcGVuaW5nIHRoZSBicm93c2VyLlxuICAgICAgICAgICAgaWYgKGlzRmlyc3RQb3BTdGF0ZUV2ZW50ICYmIHRoaXMubG9jYWxlID09PSBzdGF0ZS5vcHRpb25zLmxvY2FsZSAmJiBzdGF0ZS5hcyA9PT0gdGhpcy5hc1BhdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZm9yY2VkU2Nyb2xsO1xuICAgICAgICAgICAgY29uc3QgeyB1cmwsIGFzLCBvcHRpb25zLCBrZXkgfSA9IHN0YXRlO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcbiAgICAgICAgICAgICAgICBpZiAobWFudWFsU2Nyb2xsUmVzdG9yYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2tleSAhPT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTbmFwc2hvdCBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSgnX19uZXh0X3Njcm9sbF8nICsgdGhpcy5fa2V5LCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IHNlbGYucGFnZVhPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHNlbGYucGFnZVlPZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzdG9yZSBvbGQgc2Nyb2xsIHBvc2l0aW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbSgnX19uZXh0X3Njcm9sbF8nICsga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZWRTY3JvbGwgPSBKU09OLnBhcnNlKHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlZFNjcm9sbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9rZXkgPSBrZXk7XG4gICAgICAgICAgICBjb25zdCB7IHBhdGhuYW1lIH0gPSAoMCwgX3BhcnNlcmVsYXRpdmV1cmwucGFyc2VSZWxhdGl2ZVVybCkodXJsKTtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCByZS1yZW5kZXIgb24gaW5pdGlhbCBsb2FkLFxuICAgICAgICAgICAgLy8gY2FuIGJlIGNhdXNlZCBieSBuYXZpZ2F0aW5nIGJhY2sgZnJvbSBhbiBleHRlcm5hbCBzaXRlXG4gICAgICAgICAgICBpZiAodGhpcy5pc1NzciAmJiBhcyA9PT0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkodGhpcy5hc1BhdGgpICYmIHBhdGhuYW1lID09PSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSh0aGlzLnBhdGhuYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSBkb3duc3RyZWFtIGFwcGxpY2F0aW9uIHJldHVybnMgZmFsc3ksIHJldHVybi5cbiAgICAgICAgICAgIC8vIFRoZXkgd2lsbCB0aGVuIGJlIHJlc3BvbnNpYmxlIGZvciBoYW5kbGluZyB0aGUgZXZlbnQuXG4gICAgICAgICAgICBpZiAodGhpcy5fYnBzICYmICF0aGlzLl9icHMoc3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jaGFuZ2UoJ3JlcGxhY2VTdGF0ZScsIHVybCwgYXMsIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBzaGFsbG93OiBvcHRpb25zLnNoYWxsb3cgJiYgdGhpcy5fc2hhbGxvdyxcbiAgICAgICAgICAgICAgICBsb2NhbGU6IG9wdGlvbnMubG9jYWxlIHx8IHRoaXMuZGVmYXVsdExvY2FsZSxcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIGludGVybmFsIHZhbHVlIG5vdCBleHBvc2VkIG9uIHR5cGVzXG4gICAgICAgICAgICAgICAgX2g6IDBcbiAgICAgICAgICAgIH0pLCBmb3JjZWRTY3JvbGwpO1xuICAgICAgICB9O1xuICAgICAgICAvLyByZXByZXNlbnRzIHRoZSBjdXJyZW50IGNvbXBvbmVudCBrZXlcbiAgICAgICAgY29uc3Qgcm91dGUgPSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkocGF0aG5hbWUpO1xuICAgICAgICAvLyBzZXQgdXAgdGhlIGNvbXBvbmVudCBjYWNoZSAoYnkgcm91dGUga2V5cylcbiAgICAgICAgdGhpcy5jb21wb25lbnRzID0ge307XG4gICAgICAgIC8vIFdlIHNob3VsZCBub3Qga2VlcCB0aGUgY2FjaGUsIGlmIHRoZXJlJ3MgYW4gZXJyb3JcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGlzIGNhdXNlIGlzc3VlcyB3aGVuIHdoZW4gZ29pbmcgYmFjayBhbmRcbiAgICAgICAgLy8gY29tZSBhZ2FpbiB0byB0aGUgZXJyb3JlZCBwYWdlLlxuICAgICAgICBpZiAocGF0aG5hbWUgIT09ICcvX2Vycm9yJykge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzW3JvdXRlXSA9IHtcbiAgICAgICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgaW5pdGlhbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwcm9wczogaW5pdGlhbFByb3BzLFxuICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICBfX05fU1NHOiBpbml0aWFsUHJvcHMgJiYgaW5pdGlhbFByb3BzLl9fTl9TU0csXG4gICAgICAgICAgICAgICAgX19OX1NTUDogaW5pdGlhbFByb3BzICYmIGluaXRpYWxQcm9wcy5fX05fU1NQXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tcG9uZW50c1snL19hcHAnXSA9IHtcbiAgICAgICAgICAgIENvbXBvbmVudDogQXBwLFxuICAgICAgICAgICAgc3R5bGVTaGVldHM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXQgZm9yIFJvdXRlci5yb3V0ZXIuZXZlbnRzXG4gICAgICAgIC8vIFRPRE86IFNob3VsZCBiZSByZW1vdmUgdGhlIGZvbGxvd2luZyBtYWpvciB2ZXJzaW9uIGFzIGl0IHdhcyBuZXZlciBkb2N1bWVudGVkXG4gICAgICAgIHRoaXMuZXZlbnRzID0gUm91dGVyLmV2ZW50cztcbiAgICAgICAgdGhpcy5wYWdlTG9hZGVyID0gcGFnZUxvYWRlcjtcbiAgICAgICAgLy8gaWYgYXV0byBwcmVyZW5kZXJlZCBhbmQgZHluYW1pYyByb3V0ZSB3YWl0IHRvIHVwZGF0ZSBhc1BhdGhcbiAgICAgICAgLy8gdW50aWwgYWZ0ZXIgbW91bnQgdG8gcHJldmVudCBoeWRyYXRpb24gbWlzbWF0Y2hcbiAgICAgICAgY29uc3QgYXV0b0V4cG9ydER5bmFtaWMgPSAoMCwgX2lzZHluYW1pYy5pc0R5bmFtaWNSb3V0ZSkocGF0aG5hbWUpICYmIHNlbGYuX19ORVhUX0RBVEFfXy5hdXRvRXhwb3J0O1xuICAgICAgICB0aGlzLmJhc2VQYXRoID0gcHJvY2Vzcy5lbnYuX19ORVhUX1JPVVRFUl9CQVNFUEFUSCB8fCAnJztcbiAgICAgICAgdGhpcy5zdWIgPSBzdWJzY3JpcHRpb247XG4gICAgICAgIHRoaXMuY2xjID0gbnVsbDtcbiAgICAgICAgdGhpcy5fd3JhcEFwcCA9IHdyYXBBcHA7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0byBpZ25vcmUgZXh0cmEgcG9wU3RhdGUgaW4gc2FmYXJpIG9uIG5hdmlnYXRpbmdcbiAgICAgICAgLy8gYmFjayBmcm9tIGV4dGVybmFsIHNpdGVcbiAgICAgICAgdGhpcy5pc1NzciA9IHRydWU7XG4gICAgICAgIHRoaXMuaXNMb2NhbGVEb21haW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1JlYWR5ID0gISEoc2VsZi5fX05FWFRfREFUQV9fLmdzc3AgfHwgc2VsZi5fX05FWFRfREFUQV9fLmdpcCB8fCBzZWxmLl9fTkVYVF9EQVRBX18uaXNFeHBlcmltZW50YWxDb21waWxlIHx8IHNlbGYuX19ORVhUX0RBVEFfXy5hcHBHaXAgJiYgIXNlbGYuX19ORVhUX0RBVEFfXy5nc3AgfHwgIWF1dG9FeHBvcnREeW5hbWljICYmICFzZWxmLmxvY2F0aW9uLnNlYXJjaCAmJiAhcHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUyk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsZXMgPSBsb2NhbGVzO1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0TG9jYWxlID0gZGVmYXVsdExvY2FsZTtcbiAgICAgICAgICAgIHRoaXMuZG9tYWluTG9jYWxlcyA9IGRvbWFpbkxvY2FsZXM7XG4gICAgICAgICAgICB0aGlzLmlzTG9jYWxlRG9tYWluID0gISEoMCwgX2RldGVjdGRvbWFpbmxvY2FsZS5kZXRlY3REb21haW5Mb2NhbGUpKGRvbWFpbkxvY2FsZXMsIHNlbGYubG9jYXRpb24uaG9zdG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICByb3V0ZSxcbiAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICBhc1BhdGg6IGF1dG9FeHBvcnREeW5hbWljID8gcGF0aG5hbWUgOiBhcyxcbiAgICAgICAgICAgIGlzUHJldmlldzogISFpc1ByZXZpZXcsXG4gICAgICAgICAgICBsb2NhbGU6IHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQgPyBsb2NhbGUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBpc0ZhbGxiYWNrXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2luaXRpYWxNYXRjaGVzTWlkZGxld2FyZVByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBcImFzXCIgZG9lc24ndCBzdGFydCB3aXRoIGRvdWJsZSBzbGFzaGVzIG9yIGVsc2UgaXQgY2FuXG4gICAgICAgICAgICAvLyB0aHJvdyBhbiBlcnJvciBhcyBpdCdzIGNvbnNpZGVyZWQgaW52YWxpZFxuICAgICAgICAgICAgaWYgKCFhcy5zdGFydHNXaXRoKCcvLycpKSB7XG4gICAgICAgICAgICAgICAgLy8gaW4gb3JkZXIgZm9yIGBlLnN0YXRlYCB0byB3b3JrIG9uIHRoZSBgb25wb3BzdGF0ZWAgZXZlbnRcbiAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlIHRvIHJlZ2lzdGVyIHRoZSBpbml0aWFsIHJvdXRlIHVwb24gaW5pdGlhbGl6YXRpb25cbiAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IGFzUGF0aCA9ICgwLCBfdXRpbHMuZ2V0VVJMKSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYWxNYXRjaGVzTWlkZGxld2FyZVByb21pc2UgPSBtYXRjaGVzTWlkZGxld2FyZSh7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgICAgICAgICBhc1BhdGhcbiAgICAgICAgICAgICAgICB9KS50aGVuKChtYXRjaGVzKT0+e1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBtaWRkbGV3YXJlIG1hdGNoZXMgd2UgbGVhdmUgcmVzb2x2aW5nIHRvIHRoZSBjaGFuZ2UgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgdGhlIHNlcnZlciBuZWVkcyB0byByZXNvbHZlIGZvciBjb3JyZWN0IHByaW9yaXR5XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5fc2hvdWxkUmVzb2x2ZUhyZWYgPSBhcyAhPT0gcGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoJ3JlcGxhY2VTdGF0ZScsIG1hdGNoZXMgPyBhc1BhdGggOiAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHBhdGhuYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgIH0pLCBhc1BhdGgsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hlcztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHRoaXMub25Qb3BTdGF0ZSk7XG4gICAgICAgICAgICAvLyBlbmFibGUgY3VzdG9tIHNjcm9sbCByZXN0b3JhdGlvbiBoYW5kbGluZyB3aGVuIGF2YWlsYWJsZVxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGZhbGxiYWNrIHRvIGJyb3dzZXIncyBkZWZhdWx0IGhhbmRsaW5nXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgICAgICAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9ICdtYW51YWwnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblJvdXRlci5ldmVudHMgPSAoMCwgX21pdHQuZGVmYXVsdCkoKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsImNyZWF0ZUtleSIsImRlZmF1bHQiLCJtYXRjaGVzTWlkZGxld2FyZSIsIl9leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZW51bWVyYWJsZSIsImdldCIsIlJvdXRlciIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwiX3JlbW92ZXRyYWlsaW5nc2xhc2giLCJfcm91dGVsb2FkZXIiLCJfc2NyaXB0IiwiX2lzZXJyb3IiLCJfIiwiX2Rlbm9ybWFsaXplcGFnZXBhdGgiLCJfbm9ybWFsaXplbG9jYWxlcGF0aCIsIl9taXR0IiwiX3V0aWxzIiwiX2lzZHluYW1pYyIsIl9wYXJzZXJlbGF0aXZldXJsIiwiX3Jlc29sdmVyZXdyaXRlcyIsIl9yb3V0ZW1hdGNoZXIiLCJfcm91dGVyZWdleCIsIl9mb3JtYXR1cmwiLCJfZGV0ZWN0ZG9tYWlubG9jYWxlIiwiX3BhcnNlcGF0aCIsIl9hZGRsb2NhbGUiLCJfcmVtb3ZlbG9jYWxlIiwiX3JlbW92ZWJhc2VwYXRoIiwiX2FkZGJhc2VwYXRoIiwiX2hhc2Jhc2VwYXRoIiwiX3Jlc29sdmVocmVmIiwiX2lzYXBpcm91dGUiLCJfZ2V0bmV4dHBhdGhuYW1laW5mbyIsIl9mb3JtYXRuZXh0cGF0aG5hbWVpbmZvIiwiX2NvbXBhcmVzdGF0ZXMiLCJfaXNsb2NhbHVybCIsIl9pc2JvdCIsIl9vbWl0IiwiX2ludGVycG9sYXRlYXMiLCJfaGFuZGxlc21vb3Roc2Nyb2xsIiwiX2NvbnN0YW50cyIsImJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IiLCJhc3NpZ24iLCJFcnJvciIsImNvbmZpZ3VyYWJsZSIsImNhbmNlbGxlZCIsIm9wdGlvbnMiLCJtYXRjaGVycyIsIlByb21pc2UiLCJyZXNvbHZlIiwicm91dGVyIiwicGFnZUxvYWRlciIsImdldE1pZGRsZXdhcmUiLCJwYXRobmFtZSIsImFzUGF0aG5hbWUiLCJwYXJzZVBhdGgiLCJhc1BhdGgiLCJjbGVhbmVkQXMiLCJoYXNCYXNlUGF0aCIsInJlbW92ZUJhc2VQYXRoIiwiYXNXaXRoQmFzZVBhdGhBbmRMb2NhbGUiLCJhZGRCYXNlUGF0aCIsImFkZExvY2FsZSIsImxvY2FsZSIsInNvbWUiLCJtIiwiUmVnRXhwIiwicmVnZXhwIiwidGVzdCIsInN0cmlwT3JpZ2luIiwidXJsIiwib3JpZ2luIiwiZ2V0TG9jYXRpb25PcmlnaW4iLCJzdGFydHNXaXRoIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwicHJlcGFyZVVybEFzIiwiYXMiLCJyZXNvbHZlZEhyZWYiLCJyZXNvbHZlZEFzIiwicmVzb2x2ZUhyZWYiLCJocmVmV2FzQWJzb2x1dGUiLCJhc1dhc0Fic29sdXRlIiwicHJlcGFyZWRVcmwiLCJwcmVwYXJlZEFzIiwicmVzb2x2ZUR5bmFtaWNSb3V0ZSIsInBhZ2VzIiwiY2xlYW5QYXRobmFtZSIsInJlbW92ZVRyYWlsaW5nU2xhc2giLCJkZW5vcm1hbGl6ZVBhZ2VQYXRoIiwiaW5jbHVkZXMiLCJwYWdlIiwiaXNEeW5hbWljUm91dGUiLCJnZXRSb3V0ZVJlZ2V4IiwicmUiLCJnZXRNaWRkbGV3YXJlRGF0YSIsInNvdXJjZSIsInJlc3BvbnNlIiwibmV4dENvbmZpZyIsImJhc2VQYXRoIiwiaTE4biIsImxvY2FsZXMiLCJ0cmFpbGluZ1NsYXNoIiwiQm9vbGVhbiIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfVFJBSUxJTkdfU0xBU0giLCJyZXdyaXRlSGVhZGVyIiwiaGVhZGVycyIsInJld3JpdGVUYXJnZXQiLCJtYXRjaGVkUGF0aCIsIk1BVENIRURfUEFUSF9IRUFERVIiLCJfX05FWFRfRVhURVJOQUxfTUlERExFV0FSRV9SRVdSSVRFX1JFU09MVkUiLCJwYXJzZWRSZXdyaXRlVGFyZ2V0IiwicGFyc2VSZWxhdGl2ZVVybCIsInBhdGhuYW1lSW5mbyIsImdldE5leHRQYXRobmFtZUluZm8iLCJwYXJzZURhdGEiLCJmc1BhdGhuYW1lIiwiZ2V0UGFnZUxpc3QiLCJnZXRDbGllbnRCdWlsZE1hbmlmZXN0IiwidGhlbiIsInBhcmFtIiwiX19yZXdyaXRlcyIsInJld3JpdGVzIiwibm9ybWFsaXplTG9jYWxlUGF0aCIsInBhcnNlZFNvdXJjZSIsIl9fTkVYVF9IQVNfUkVXUklURVMiLCJ1bmRlZmluZWQiLCJyZXN1bHQiLCJxdWVyeSIsInBhdGgiLCJtYXRjaGVkUGFnZSIsInBhcnNlZEFzIiwicmVzb2x2ZWRQYXRobmFtZSIsIm1hdGNoZXMiLCJnZXRSb3V0ZU1hdGNoZXIiLCJ0eXBlIiwic3JjIiwiZm9ybWF0TmV4dFBhdGhuYW1lSW5mbyIsImRlZmF1bHRMb2NhbGUiLCJidWlsZElkIiwiZGVzdGluYXRpb24iLCJoYXNoIiwicmVkaXJlY3RUYXJnZXQiLCJuZXdBcyIsIm5ld1VybCIsIndpdGhNaWRkbGV3YXJlRWZmZWN0cyIsImZldGNoRGF0YSIsImRhdGEiLCJlZmZlY3QiLCJkYXRhSHJlZiIsImpzb24iLCJ0ZXh0IiwiY2FjaGVLZXkiLCJtYW51YWxTY3JvbGxSZXN0b3JhdGlvbiIsIl9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04iLCJ3aW5kb3ciLCJoaXN0b3J5IiwidiIsInNlc3Npb25TdG9yYWdlIiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJuIiwiU1NHX0RBVEFfTk9UX0ZPVU5EIiwiU3ltYm9sIiwiZmV0Y2hSZXRyeSIsImF0dGVtcHRzIiwiZmV0Y2giLCJjcmVkZW50aWFscyIsIm1ldGhvZCIsIm9rIiwic3RhdHVzIiwidHJ5VG9QYXJzZUFzSlNPTiIsIkpTT04iLCJwYXJzZSIsImVycm9yIiwiZmV0Y2hOZXh0RGF0YSIsImluZmxpZ2h0Q2FjaGUiLCJpc1ByZWZldGNoIiwiaGFzTWlkZGxld2FyZSIsImlzU2VydmVyUmVuZGVyIiwicGFyc2VKU09OIiwicGVyc2lzdENhY2hlIiwiaXNCYWNrZ3JvdW5kIiwidW5zdGFibGVfc2tpcENsaWVudENhY2hlIiwiaHJlZiIsIlVSTCIsImxvY2F0aW9uIiwiZ2V0RGF0YSIsInBhcmFtcyIsIl9wYXJhbXNfbWV0aG9kIiwicHVycG9zZSIsIk5FWFRfREVQTE9ZTUVOVF9JRCIsIl90cnlUb1BhcnNlQXNKU09OIiwibm90Rm91bmQiLCJtYXJrQXNzZXRFcnJvciIsImNhdGNoIiwiZXJyIiwibWVzc2FnZSIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInNsaWNlIiwiaGFuZGxlSGFyZE5hdmlnYXRpb24iLCJnZXRDYW5jZWxsZWRIYW5kbGVyIiwicm91dGUiLCJjYW5jZWwiLCJjbGMiLCJoYW5kbGVDYW5jZWxsZWQiLCJyZWxvYWQiLCJiYWNrIiwiZm9yd2FyZCIsInB1c2giLCJfa2V5Iiwic3RyaW5naWZ5IiwieCIsInNlbGYiLCJwYWdlWE9mZnNldCIsInkiLCJwYWdlWU9mZnNldCIsImUiLCJjaGFuZ2UiLCJyZXBsYWNlIiwiX2JmbCIsInNraXBOYXZpZ2F0ZSIsIl9fTkVYVF9DTElFTlRfUk9VVEVSX0ZJTFRFUl9FTkFCTEVEIiwiX2JmbF9zIiwiX2JmbF9kIiwiQmxvb21GaWx0ZXIiLCJzdGF0aWNGaWx0ZXJEYXRhIiwiZHluYW1pY0ZpbHRlckRhdGEiLCJfX3JvdXRlckZpbHRlclN0YXRpYyIsIl9fcm91dGVyRmlsdGVyRHluYW1pYyIsImNvbnNvbGUiLCJyb3V0ZXJGaWx0ZXJTVmFsdWUiLCJfX05FWFRfQ0xJRU5UX1JPVVRFUl9TX0ZJTFRFUiIsInJvdXRlckZpbHRlckRWYWx1ZSIsIl9fTkVYVF9DTElFTlRfUk9VVEVSX0RfRklMVEVSIiwibnVtSGFzaGVzIiwibnVtSXRlbXMiLCJlcnJvclJhdGUiLCJpbXBvcnQiLCJtYXRjaGVzQmZsU3RhdGljIiwibWF0Y2hlc0JmbER5bmFtaWMiLCJwYXRoc1RvQ2hlY2siLCJjdXJBcyIsImFsbG93TWF0Y2hDdXJyZW50IiwiYXNOb1NsYXNoIiwiYXNOb1NsYXNoTG9jYWxlIiwiX3RoaXNfX2JmbF9zIiwiX3RoaXNfX2JmbF9zMSIsImNvbnRhaW5zIiwibm9ybWFsaXplZEFTIiwiY3VyQXNQYXJ0cyIsInNwbGl0IiwiaSIsIl90aGlzX19iZmxfZCIsImN1cnJlbnRQYXJ0Iiwiam9pbiIsImZvcmNlZFNjcm9sbCIsIl90aGlzX2NvbXBvbmVudHNfcGF0aG5hbWUiLCJpc0xvY2FsVVJMIiwiaXNRdWVyeVVwZGF0aW5nIiwiX2giLCJzaGFsbG93Iiwic2hvdWxkUmVzb2x2ZUhyZWYiLCJfc2hvdWxkUmVzb2x2ZUhyZWYiLCJuZXh0U3RhdGUiLCJzdGF0ZSIsInJlYWR5U3RhdGVDaGFuZ2UiLCJpc1JlYWR5IiwiaXNTc3IiLCJwcmV2TG9jYWxlIiwiX19ORVhUX0kxOE5fU1VQUE9SVCIsImxvY2FsZVBhdGhSZXN1bHQiLCJkZXRlY3RlZExvY2FsZSIsImZvcm1hdFdpdGhWYWxpZGF0aW9uIiwiZGlkTmF2aWdhdGUiLCJfdGhpc19sb2NhbGVzIiwiZGV0ZWN0ZWREb21haW4iLCJkZXRlY3REb21haW5Mb2NhbGUiLCJkb21haW5Mb2NhbGVzIiwiaXNMb2NhbGVEb21haW4iLCJob3N0bmFtZSIsImRvbWFpbiIsImFzTm9CYXNlUGF0aCIsImh0dHAiLCJTVCIsInBlcmZvcm1hbmNlIiwibWFyayIsInNjcm9sbCIsInJvdXRlUHJvcHMiLCJfaW5GbGlnaHRSb3V0ZSIsImV2ZW50cyIsImVtaXQiLCJyZW1vdmVMb2NhbGUiLCJsb2NhbGVDaGFuZ2UiLCJvbmx5QUhhc2hDaGFuZ2UiLCJjaGFuZ2VTdGF0ZSIsInNjcm9sbFRvSGFzaCIsInNldCIsImNvbXBvbmVudHMiLCJwYXJzZWQiLCJ1cmxJc05ldyIsInBhcnNlZEFzUGF0aG5hbWUiLCJfX2FwcFJvdXRlciIsImlzTWlkZGxld2FyZVJld3JpdGUiLCJpc01pZGRsZXdhcmVNYXRjaCIsInJld3JpdGVzUmVzdWx0IiwicCIsImV4dGVybmFsRGVzdCIsInJvdXRlTWF0Y2giLCJyb3V0ZVJlZ2V4Iiwic2hvdWxkSW50ZXJwb2xhdGUiLCJpbnRlcnBvbGF0ZWRBcyIsImludGVycG9sYXRlQXMiLCJtaXNzaW5nUGFyYW1zIiwia2V5cyIsImdyb3VwcyIsImZpbHRlciIsIm9wdGlvbmFsIiwid2FybiIsIm9taXQiLCJpc0Vycm9yUm91dGUiLCJfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzX3BhZ2VQcm9wcyIsIl9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHMiLCJfcm91dGVJbmZvX3Byb3BzIiwicm91dGVJbmZvIiwiZ2V0Um91dGVJbmZvIiwiaXNQcmV2aWV3IiwiaXNGYWxsYmFjayIsImNsZWFuZWRQYXJzZWRQYXRobmFtZSIsImZvckVhY2giLCJrZXkiLCJwcmVmaXhlZEFzIiwicmV3cml0ZUFzIiwibG9jYWxlUmVzdWx0IiwiY3VyUm91dGVNYXRjaCIsImNvbXBvbmVudCIsIkNvbXBvbmVudCIsInVuc3RhYmxlX3NjcmlwdExvYWRlciIsInNjcmlwdHMiLCJjb25jYXQiLCJzY3JpcHQiLCJoYW5kbGVDbGllbnRTY3JpcHRMb2FkIiwicHJvcHMiLCJfX05fU1NHIiwiX19OX1NTUCIsInBhZ2VQcm9wcyIsIl9fTl9SRURJUkVDVCIsIl9fTl9SRURJUkVDVF9CQVNFX1BBVEgiLCJwYXJzZWRIcmVmIiwiX19OX1BSRVZJRVciLCJub3RGb3VuZFJvdXRlIiwiZmV0Y2hDb21wb25lbnQiLCJpc05vdEZvdW5kIiwiX19ORVhUX0RBVEFfXyIsInN0YXR1c0NvZGUiLCJfcm91dGVJbmZvX3JvdXRlIiwiaXNWYWxpZFNoYWxsb3dSb3V0ZSIsIl9vcHRpb25zX3Njcm9sbCIsInNob3VsZFNjcm9sbCIsInJlc2V0U2Nyb2xsIiwidXBjb21pbmdTY3JvbGxTdGF0ZSIsInVwY29taW5nUm91dGVyU3RhdGUiLCJfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzX3BhZ2VQcm9wczEiLCJfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzMSIsIl9yb3V0ZUluZm9fcHJvcHMxIiwiY2FuU2tpcFVwZGF0aW5nIiwiY29tcGFyZVJvdXRlclN0YXRlcyIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwibGFuZyIsImhhc2hSZWdleCIsImdldFVSTCIsIl9zaGFsbG93IiwiX19OIiwiaGFuZGxlUm91dGVJbmZvRXJyb3IiLCJsb2FkRXJyb3JGYWlsIiwiaXNBc3NldEVycm9yIiwic3R5bGVTaGVldHMiLCJnZXRJbml0aWFsUHJvcHMiLCJnaXBFcnIiLCJyb3V0ZUluZm9FcnIiLCJyZXF1ZXN0ZWRSb3V0ZSIsIl9kYXRhX2VmZmVjdCIsIl9kYXRhX2VmZmVjdDEiLCJfZGF0YV9lZmZlY3QyIiwiX2RhdGFfcmVzcG9uc2UiLCJleGlzdGluZ0luZm8iLCJjYWNoZWRSb3V0ZUluZm8iLCJmZXRjaE5leHREYXRhUGFyYW1zIiwiZ2V0RGF0YUhyZWYiLCJza2lwSW50ZXJwb2xhdGlvbiIsInNiYyIsInNkYyIsInJlc29sdmVkUm91dGUiLCJpc0FQSVJvdXRlIiwicmVzIiwibW9kIiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwid2FzQmFpbGVkUHJlZmV0Y2giLCJzaG91bGRGZXRjaERhdGEiLCJfZ2V0RGF0YSIsImZldGNoZWQiLCJnZXRQcm9wZXJFcnJvciIsInN1YiIsImJlZm9yZVBvcFN0YXRlIiwiY2IiLCJfYnBzIiwib2xkVXJsTm9IYXNoIiwib2xkSGFzaCIsIm5ld1VybE5vSGFzaCIsIm5ld0hhc2giLCJoYW5kbGVTbW9vdGhTY3JvbGwiLCJzY3JvbGxUbyIsInJhd0hhc2giLCJkZWNvZGVVUklDb21wb25lbnQiLCJpZEVsIiwiZ2V0RWxlbWVudEJ5SWQiLCJzY3JvbGxJbnRvVmlldyIsIm5hbWVFbCIsImdldEVsZW1lbnRzQnlOYW1lIiwib25seUhhc2hDaGFuZ2UiLCJwcmVmZXRjaCIsImlzQm90IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwidXJsUGF0aG5hbWUiLCJvcmlnaW5hbFBhdGhuYW1lIiwiX19ORVhUX01JRERMRVdBUkVfUFJFRkVUQ0giLCJfaXNTc2ciLCJpc1NzZyIsInByaW9yaXR5IiwiX19ORVhUX09QVElNSVNUSUNfQ0xJRU5UX0NBQ0hFIiwiY29tcG9uZW50UmVzdWx0IiwibG9hZFBhZ2UiLCJmbiIsImN0eCIsIkFwcCIsIkFwcFRyZWUiLCJfd3JhcEFwcCIsImxvYWRHZXRJbml0aWFsUHJvcHMiLCJjb25zdHJ1Y3RvciIsImluaXRpYWxQcm9wcyIsIndyYXBBcHAiLCJzdWJzY3JpcHRpb24iLCJpc0ZpcnN0UG9wU3RhdGVFdmVudCIsIm9uUG9wU3RhdGUiLCJfX05BIiwiZ2V0SXRlbSIsImluaXRpYWwiLCJhdXRvRXhwb3J0RHluYW1pYyIsImF1dG9FeHBvcnQiLCJfX05FWFRfUk9VVEVSX0JBU0VQQVRIIiwiZ3NzcCIsImdpcCIsImlzRXhwZXJpbWVudGFsQ29tcGlsZSIsImFwcEdpcCIsImdzcCIsInNlYXJjaCIsIl9pbml0aWFsTWF0Y2hlc01pZGRsZXdhcmVQcm9taXNlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInNjcm9sbFJlc3RvcmF0aW9uIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/router.js\n"));

/***/ })

});